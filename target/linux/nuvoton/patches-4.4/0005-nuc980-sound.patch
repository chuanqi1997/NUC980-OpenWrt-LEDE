diff -uprN linux-4.4.194/sound/soc/codecs/Kconfig NUC980-linux-4.4.194/sound/soc/codecs/Kconfig
--- linux-4.4.194/sound/soc/codecs/Kconfig	2019-09-20 22:12:54.000000000 -0700
+++ NUC980-linux-4.4.194/sound/soc/codecs/Kconfig	2019-12-29 19:12:21.000000000 -0800
@@ -911,6 +911,9 @@ config SND_SOC_ML26124
 config SND_SOC_NAU8825
 	tristate
 
+config SND_SOC_NAU8822
+	tristate
+
 config SND_SOC_TPA6130A2
 	tristate "Texas Instruments TPA6130A2 headphone amplifier"
 	depends on I2C
diff -uprN linux-4.4.194/sound/soc/codecs/Makefile NUC980-linux-4.4.194/sound/soc/codecs/Makefile
--- linux-4.4.194/sound/soc/codecs/Makefile	2019-09-20 22:12:54.000000000 -0700
+++ NUC980-linux-4.4.194/sound/soc/codecs/Makefile	2019-12-29 19:12:21.000000000 -0800
@@ -75,6 +75,7 @@ snd-soc-max9850-objs := max9850.o
 snd-soc-mc13783-objs := mc13783.o
 snd-soc-ml26124-objs := ml26124.o
 snd-soc-nau8825-objs := nau8825.o
+snd-soc-nau8822-objs := nau8822.o
 snd-soc-pcm1681-objs := pcm1681.o
 snd-soc-pcm1792a-codec-objs := pcm1792a.o
 snd-soc-pcm3008-objs := pcm3008.o
@@ -270,6 +271,7 @@ obj-$(CONFIG_SND_SOC_MAX9850)	+= snd-soc
 obj-$(CONFIG_SND_SOC_MC13783)	+= snd-soc-mc13783.o
 obj-$(CONFIG_SND_SOC_ML26124)	+= snd-soc-ml26124.o
 obj-$(CONFIG_SND_SOC_NAU8825)   += snd-soc-nau8825.o
+obj-$(CONFIG_SND_SOC_NAU8822)	+= snd-soc-nau8822.o
 obj-$(CONFIG_SND_SOC_PCM1681)	+= snd-soc-pcm1681.o
 obj-$(CONFIG_SND_SOC_PCM1792A)	+= snd-soc-pcm1792a-codec.o
 obj-$(CONFIG_SND_SOC_PCM3008)	+= snd-soc-pcm3008.o
diff -uprN linux-4.4.194/sound/soc/codecs/nau8822.c NUC980-linux-4.4.194/sound/soc/codecs/nau8822.c
--- linux-4.4.194/sound/soc/codecs/nau8822.c	1969-12-31 16:00:00.000000000 -0800
+++ NUC980-linux-4.4.194/sound/soc/codecs/nau8822.c	2019-12-29 19:12:21.000000000 -0800
@@ -0,0 +1,1162 @@
+/*
+ * nau8822.c  --  NAU8822 ALSA SoC Audio Codec driver
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2007 Carlos Munoz <carlos@kenati.com>
+ * Copyright 2006-2009 Wolfson Microelectronics PLC.
+ * Based on wm8974 and wm8990 by Liam Girdwood <lrg@slimlogic.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <asm/div64.h>
+
+#include "nau8822.h"
+
+static const struct reg_default nau8822_reg_defaults[] = {
+	{ 1, 0x0000 },
+	{ 2, 0x0000 },
+	{ 3, 0x0000 },
+	{ 4, 0x0050 },
+	{ 5, 0x0000 },
+	{ 6, 0x0140 },
+	{ 7, 0x0000 },
+	{ 8, 0x0000 },
+	{ 9, 0x0000 },
+	{ 10, 0x0000 },
+	{ 11, 0x00ff },
+	{ 12, 0x00ff },
+	{ 13, 0x0000 },
+	{ 14, 0x0100 },
+	{ 15, 0x00ff },
+	{ 16, 0x00ff },
+	{ 17, 0x0000 },
+	{ 18, 0x012c },
+	{ 19, 0x002c },
+	{ 20, 0x002c },
+	{ 21, 0x002c },
+	{ 22, 0x002c },
+	{ 23, 0x0000 },
+	{ 24, 0x0032 },
+	{ 25, 0x0000 },
+	{ 26, 0x0000 },
+	{ 27, 0x0000 },
+	{ 28, 0x0000 },
+	{ 29, 0x0000 },
+	{ 30, 0x0000 },
+	{ 31, 0x0000 },
+	{ 32, 0x0038 },
+	{ 33, 0x000b },
+	{ 34, 0x0032 },
+	{ 35, 0x0000 },
+	{ 36, 0x0008 },
+	{ 37, 0x000c },
+	{ 38, 0x0093 },
+	{ 39, 0x00e9 },
+	{ 40, 0x0000 },
+	{ 41, 0x0000 },
+	{ 42, 0x0000 },
+	{ 43, 0x0000 },
+	{ 44, 0x0033 },
+	{ 45, 0x0010 },
+	{ 46, 0x0010 },
+	{ 47, 0x0100 },
+	{ 48, 0x0100 },
+	{ 49, 0x0002 },
+	{ 50, 0x0001 },
+	{ 51, 0x0001 },
+	{ 52, 0x0039 },
+	{ 53, 0x0039 },
+	{ 54, 0x0039 },
+	{ 55, 0x0039 },
+	{ 56, 0x0001 },
+	{ 57, 0x0001 },
+};
+
+static bool nau8822_volatile(struct device *dev, unsigned int reg)
+{
+	return reg == NAU8822_RESET;
+}
+
+/* codec private data */
+struct nau8822_priv {
+	struct regmap *regmap;
+	struct snd_soc_dapm_context *dapm;
+	unsigned int f_pllout;
+	unsigned int f_mclk;
+	unsigned int f_256fs;
+	unsigned int f_opclk;
+	int mclk_idx;
+	enum nau8822_sysclk_src sysclk;
+};
+
+static const char *nau8822_companding[] = {"Off", "NC", "u-law", "A-law"};
+static const char *nau8822_eqmode[] = {"Capture", "Playback"};
+static const char *nau8822_bw[] = {"Narrow", "Wide"};
+static const char *nau8822_eq1[] = {"80Hz", "105Hz", "135Hz", "175Hz"};
+static const char *nau8822_eq2[] = {"230Hz", "300Hz", "385Hz", "500Hz"};
+static const char *nau8822_eq3[] = {"650Hz", "850Hz", "1.1kHz", "1.4kHz"};
+static const char *nau8822_eq4[] = {"1.8kHz", "2.4kHz", "3.2kHz", "4.1kHz"};
+static const char *nau8822_eq5[] = {"5.3kHz", "6.9kHz", "9kHz", "11.7kHz"};
+static const char *nau8822_alc3[] = {"ALC", "Limiter"};
+static const char *nau8822_alc1[] = {"Off", "Right", "Left", "Both"};
+
+static const SOC_ENUM_SINGLE_DECL(adc_compand, NAU8822_COMPANDING_CONTROL, 1,
+				  nau8822_companding);
+static const SOC_ENUM_SINGLE_DECL(dac_compand, NAU8822_COMPANDING_CONTROL, 3,
+				  nau8822_companding);
+static const SOC_ENUM_SINGLE_DECL(eqmode, NAU8822_EQ1, 8, nau8822_eqmode);
+static const SOC_ENUM_SINGLE_DECL(eq1, NAU8822_EQ1, 5, nau8822_eq1);
+static const SOC_ENUM_SINGLE_DECL(eq2bw, NAU8822_EQ2, 8, nau8822_bw);
+static const SOC_ENUM_SINGLE_DECL(eq2, NAU8822_EQ2, 5, nau8822_eq2);
+static const SOC_ENUM_SINGLE_DECL(eq3bw, NAU8822_EQ3, 8, nau8822_bw);
+static const SOC_ENUM_SINGLE_DECL(eq3, NAU8822_EQ3, 5, nau8822_eq3);
+static const SOC_ENUM_SINGLE_DECL(eq4bw, NAU8822_EQ4, 8, nau8822_bw);
+static const SOC_ENUM_SINGLE_DECL(eq4, NAU8822_EQ4, 5, nau8822_eq4);
+static const SOC_ENUM_SINGLE_DECL(eq5, NAU8822_EQ5, 5, nau8822_eq5);
+static const SOC_ENUM_SINGLE_DECL(alc3, NAU8822_ALC_CONTROL_3, 8, nau8822_alc3);
+static const SOC_ENUM_SINGLE_DECL(alc1, NAU8822_ALC_CONTROL_1, 7, nau8822_alc1);
+
+static const DECLARE_TLV_DB_SCALE(digital_tlv, -12750, 50, 1);
+static const DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
+static const DECLARE_TLV_DB_SCALE(inpga_tlv, -1200, 75, 0);
+static const DECLARE_TLV_DB_SCALE(spk_tlv, -5700, 100, 0);
+static const DECLARE_TLV_DB_SCALE(boost_tlv, -1500, 300, 1);
+static const DECLARE_TLV_DB_SCALE(limiter_tlv, 0, 100, 0);
+
+static const struct snd_kcontrol_new nau8822_snd_controls[] = {
+
+	SOC_SINGLE("Digital Loopback Switch",
+		NAU8822_COMPANDING_CONTROL, 0, 1, 0),
+
+	SOC_ENUM("ADC Companding", adc_compand),
+	SOC_ENUM("DAC Companding", dac_compand),
+
+	SOC_DOUBLE("DAC Inversion Switch", NAU8822_DAC_CONTROL, 0, 1, 1, 0),
+
+	SOC_DOUBLE_R_TLV("PCM Volume",
+		NAU8822_LEFT_DAC_DIGITAL_VOLUME, NAU8822_RIGHT_DAC_DIGITAL_VOLUME,
+		0, 255, 0, digital_tlv),
+
+	SOC_SINGLE("High Pass Filter Switch", NAU8822_ADC_CONTROL, 8, 1, 0),
+	SOC_SINGLE("High Pass Cut Off", NAU8822_ADC_CONTROL, 4, 7, 0),
+	SOC_DOUBLE("ADC Inversion Switch", NAU8822_ADC_CONTROL, 0, 1, 1, 0),
+
+	SOC_DOUBLE_R_TLV("ADC Volume",
+		NAU8822_LEFT_ADC_DIGITAL_VOLUME, NAU8822_RIGHT_ADC_DIGITAL_VOLUME,
+		0, 255, 0, digital_tlv),
+
+	SOC_ENUM("Equaliser Function", eqmode),
+	SOC_ENUM("EQ1 Cut Off", eq1),
+	SOC_SINGLE_TLV("EQ1 Volume", NAU8822_EQ1,  0, 24, 1, eq_tlv),
+
+	SOC_ENUM("Equaliser EQ2 Bandwidth", eq2bw),
+	SOC_ENUM("EQ2 Cut Off", eq2),
+	SOC_SINGLE_TLV("EQ2 Volume", NAU8822_EQ2,  0, 24, 1, eq_tlv),
+
+	SOC_ENUM("Equaliser EQ3 Bandwidth", eq3bw),
+	SOC_ENUM("EQ3 Cut Off", eq3),
+	SOC_SINGLE_TLV("EQ3 Volume", NAU8822_EQ3,  0, 24, 1, eq_tlv),
+
+	SOC_ENUM("Equaliser EQ4 Bandwidth", eq4bw),
+	SOC_ENUM("EQ4 Cut Off", eq4),
+	SOC_SINGLE_TLV("EQ4 Volume", NAU8822_EQ4,  0, 24, 1, eq_tlv),
+
+	SOC_ENUM("EQ5 Cut Off", eq5),
+	SOC_SINGLE_TLV("EQ5 Volume", NAU8822_EQ5, 0, 24, 1, eq_tlv),
+
+	SOC_SINGLE("DAC Playback Limiter Switch",
+		NAU8822_DAC_LIMITER_1, 8, 1, 0),
+	SOC_SINGLE("DAC Playback Limiter Decay",
+		NAU8822_DAC_LIMITER_1, 4, 15, 0),
+	SOC_SINGLE("DAC Playback Limiter Attack",
+		NAU8822_DAC_LIMITER_1, 0, 15, 0),
+
+	SOC_SINGLE("DAC Playback Limiter Threshold",
+		NAU8822_DAC_LIMITER_2, 4, 7, 0),
+	SOC_SINGLE_TLV("DAC Playback Limiter Volume",
+		NAU8822_DAC_LIMITER_2, 0, 12, 0, limiter_tlv),
+
+	SOC_ENUM("ALC Enable Switch", alc1),
+	SOC_SINGLE("ALC Capture Min Gain", NAU8822_ALC_CONTROL_1, 0, 7, 0),
+	SOC_SINGLE("ALC Capture Max Gain", NAU8822_ALC_CONTROL_1, 3, 7, 0),
+
+	SOC_SINGLE("ALC Capture Hold", NAU8822_ALC_CONTROL_2, 4, 10, 0),
+	SOC_SINGLE("ALC Capture Target", NAU8822_ALC_CONTROL_2, 0, 15, 0),
+
+	SOC_ENUM("ALC Capture Mode", alc3),
+	SOC_SINGLE("ALC Capture Decay", NAU8822_ALC_CONTROL_3, 4, 10, 0),
+	SOC_SINGLE("ALC Capture Attack", NAU8822_ALC_CONTROL_3, 0, 10, 0),
+
+	SOC_SINGLE("ALC Capture Noise Gate Switch", NAU8822_NOISE_GATE, 3, 1, 0),
+	SOC_SINGLE("ALC Capture Noise Gate Threshold",
+		NAU8822_NOISE_GATE, 0, 7, 0),
+
+	SOC_DOUBLE_R("Capture PGA ZC Switch",
+		NAU8822_LEFT_INP_PGA_CONTROL, NAU8822_RIGHT_INP_PGA_CONTROL,
+		7, 1, 0),
+
+	/* OUT1 - Headphones */
+	SOC_DOUBLE_R("Headphone Playback ZC Switch",
+		NAU8822_LOUT1_HP_CONTROL, NAU8822_ROUT1_HP_CONTROL, 7, 1, 0),
+
+	SOC_DOUBLE_R_TLV("Headphone Playback Volume",
+		NAU8822_LOUT1_HP_CONTROL, NAU8822_ROUT1_HP_CONTROL,
+		0, 63, 0, spk_tlv),
+
+	/* OUT2 - Speakers */
+	SOC_DOUBLE_R("Speaker Playback ZC Switch",
+		NAU8822_LOUT2_SPK_CONTROL, NAU8822_ROUT2_SPK_CONTROL, 7, 1, 0),
+
+	SOC_DOUBLE_R_TLV("Speaker Playback Volume",
+		NAU8822_LOUT2_SPK_CONTROL, NAU8822_ROUT2_SPK_CONTROL,
+		0, 63, 0, spk_tlv),
+
+	/* OUT3/4 - Line Output */
+	SOC_DOUBLE_R("Line Playback Switch",
+		NAU8822_OUT3_MIXER_CONTROL, NAU8822_OUT4_MIXER_CONTROL, 6, 1, 1),
+
+	/* Mixer #3: Boost (Input) mixer */
+	SOC_DOUBLE_R("PGA Boost (+20dB)",
+		NAU8822_LEFT_ADC_BOOST_CONTROL, NAU8822_RIGHT_ADC_BOOST_CONTROL,
+		8, 1, 0),
+	SOC_DOUBLE_R_TLV("L2/R2 Boost Volume",
+		NAU8822_LEFT_ADC_BOOST_CONTROL, NAU8822_RIGHT_ADC_BOOST_CONTROL,
+		4, 7, 0, boost_tlv),
+	SOC_DOUBLE_R_TLV("Aux Boost Volume",
+		NAU8822_LEFT_ADC_BOOST_CONTROL, NAU8822_RIGHT_ADC_BOOST_CONTROL,
+		0, 7, 0, boost_tlv),
+
+	/* Input PGA volume */
+	SOC_DOUBLE_R_TLV("Input PGA Volume",
+		NAU8822_LEFT_INP_PGA_CONTROL, NAU8822_RIGHT_INP_PGA_CONTROL,
+		0, 63, 0, inpga_tlv),
+
+	/* Headphone */
+	SOC_DOUBLE_R("Headphone Switch",
+		NAU8822_LOUT1_HP_CONTROL, NAU8822_ROUT1_HP_CONTROL, 6, 1, 1),
+
+	/* Speaker */
+	SOC_DOUBLE_R("Speaker Switch",
+		NAU8822_LOUT2_SPK_CONTROL, NAU8822_ROUT2_SPK_CONTROL, 6, 1, 1),
+
+	/* DAC / ADC oversampling */
+	SOC_SINGLE("DAC 128x Oversampling Switch", NAU8822_DAC_CONTROL,
+		   5, 1, 0),
+	SOC_SINGLE("ADC 128x Oversampling Switch", NAU8822_ADC_CONTROL,
+		   5, 1, 0),
+    SOC_SINGLE("Mic Bias", NAU8822_POWER_MANAGEMENT_1,
+		   4, 1, 0),
+};
+
+/* Mixer #1: Output (OUT1, OUT2) Mixer: mix AUX, Input mixer output and DAC */
+static const struct snd_kcontrol_new nau8822_left_out_mixer[] = {
+	SOC_DAPM_SINGLE("Line Bypass Switch", NAU8822_LEFT_MIXER_CONTROL, 1, 1, 0),
+	SOC_DAPM_SINGLE("Aux Playback Switch", NAU8822_LEFT_MIXER_CONTROL, 5, 1, 0),
+	SOC_DAPM_SINGLE("PCM Playback Switch", NAU8822_LEFT_MIXER_CONTROL, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new nau8822_right_out_mixer[] = {
+	SOC_DAPM_SINGLE("Line Bypass Switch", NAU8822_RIGHT_MIXER_CONTROL, 1, 1, 0),
+	SOC_DAPM_SINGLE("Aux Playback Switch", NAU8822_RIGHT_MIXER_CONTROL, 5, 1, 0),
+	SOC_DAPM_SINGLE("PCM Playback Switch", NAU8822_RIGHT_MIXER_CONTROL, 0, 1, 0),
+};
+
+/* OUT3/OUT4 Mixer not implemented */
+static const struct snd_kcontrol_new nau8822_aux1_out_mixer[] = {
+        SOC_DAPM_SINGLE("Left Output Mixer Switch", NAU8822_OUT4_MIXER_CONTROL, 4, 1, 0),
+        SOC_DAPM_SINGLE("Right Output Mixer Switch", NAU8822_OUT4_MIXER_CONTROL, 1, 1, 0),
+        SOC_DAPM_SINGLE("Left DAC Switch", NAU8822_OUT4_MIXER_CONTROL, 3, 1, 0),
+        SOC_DAPM_SINGLE("Right DAC Switch", NAU8822_OUT4_MIXER_CONTROL, 0, 1, 0),
+        SOC_DAPM_SINGLE("Right RADC Mix/Boost Switch", NAU8822_OUT4_MIXER_CONTROL, 2, 1, 0),
+};
+
+static const struct snd_kcontrol_new nau8822_aux2_out_mixer[] = {
+        SOC_DAPM_SINGLE("Left Output Mixer Switch", NAU8822_OUT3_MIXER_CONTROL, 1, 1, 0),
+        SOC_DAPM_SINGLE("Left DAC Switch", NAU8822_OUT3_MIXER_CONTROL, 0, 1, 0),
+        SOC_DAPM_SINGLE("Left RADC Mix/Boost Switch", NAU8822_OUT3_MIXER_CONTROL, 2, 1, 0),
+        SOC_DAPM_SINGLE("Aux1 Mixer Switch", NAU8822_OUT3_MIXER_CONTROL, 3, 1, 0),
+};
+
+/* Mixer #2: Input PGA Mute */
+static const struct snd_kcontrol_new nau8822_left_input_mixer[] = {
+	SOC_DAPM_SINGLE("L2 Switch", NAU8822_INPUT_CONTROL, 2, 1, 0),
+	SOC_DAPM_SINGLE("MicN Switch", NAU8822_INPUT_CONTROL, 1, 1, 0),
+	SOC_DAPM_SINGLE("MicP Switch", NAU8822_INPUT_CONTROL, 0, 1, 0),
+};
+static const struct snd_kcontrol_new nau8822_right_input_mixer[] = {
+	SOC_DAPM_SINGLE("R2 Switch", NAU8822_INPUT_CONTROL, 6, 1, 0),
+	SOC_DAPM_SINGLE("MicN Switch", NAU8822_INPUT_CONTROL, 5, 1, 0),
+	SOC_DAPM_SINGLE("MicP Switch", NAU8822_INPUT_CONTROL, 4, 1, 0),
+};
+
+static const struct snd_soc_dapm_widget nau8822_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("Left DAC", "Left HiFi Playback",
+			 NAU8822_POWER_MANAGEMENT_3, 0, 0),
+	SND_SOC_DAPM_DAC("Right DAC", "Right HiFi Playback",
+			 NAU8822_POWER_MANAGEMENT_3, 1, 0),
+	SND_SOC_DAPM_ADC("Left ADC", "Left HiFi Capture",
+			 NAU8822_POWER_MANAGEMENT_2, 0, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "Right HiFi Capture",
+			 NAU8822_POWER_MANAGEMENT_2, 1, 0),
+
+	/* Mixer #1: OUT1,2 */
+	SOC_MIXER_ARRAY("Left Output Mixer", NAU8822_POWER_MANAGEMENT_3,
+			2, 0, nau8822_left_out_mixer),
+	SOC_MIXER_ARRAY("Right Output Mixer", NAU8822_POWER_MANAGEMENT_3,
+			3, 0, nau8822_right_out_mixer),
+
+	SOC_MIXER_ARRAY("Left Input Mixer", NAU8822_POWER_MANAGEMENT_2,
+			2, 0, nau8822_left_input_mixer),
+	SOC_MIXER_ARRAY("Right Input Mixer", NAU8822_POWER_MANAGEMENT_2,
+			3, 0, nau8822_right_input_mixer),
+
+	SND_SOC_DAPM_PGA("Left Boost Mixer", NAU8822_POWER_MANAGEMENT_2,
+			 4, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Boost Mixer", NAU8822_POWER_MANAGEMENT_2,
+			 5, 0, NULL, 0),
+
+	SND_SOC_DAPM_PGA("Left Capture PGA", NAU8822_LEFT_INP_PGA_CONTROL,
+			 6, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Capture PGA", NAU8822_RIGHT_INP_PGA_CONTROL,
+			 6, 1, NULL, 0),
+
+	SND_SOC_DAPM_PGA("Left Headphone Out", NAU8822_POWER_MANAGEMENT_2,
+			 7, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Headphone Out", NAU8822_POWER_MANAGEMENT_2,
+			 8, 0, NULL, 0),
+
+	SND_SOC_DAPM_PGA("Left Speaker Out", NAU8822_POWER_MANAGEMENT_3,
+			 6, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Speaker Out", NAU8822_POWER_MANAGEMENT_3,
+			 5, 0, NULL, 0),
+
+	SND_SOC_DAPM_MIXER("OUT4 VMID", NAU8822_POWER_MANAGEMENT_3,
+			   8, 0, NULL, 0),
+
+
+		/////////////////////////////
+
+		SND_SOC_DAPM_PGA("Aux1 Out", NAU8822_POWER_MANAGEMENT_3,
+        8, 0, NULL, 0),
+        SND_SOC_DAPM_PGA("Aux2 Out", NAU8822_POWER_MANAGEMENT_3,
+        7, 0, NULL, 0),
+
+        SOC_MIXER_ARRAY("Aux1 Out Mixer", NAU8822_POWER_MANAGEMENT_1,
+        7, 0, nau8822_aux1_out_mixer),
+        SOC_MIXER_ARRAY("Aux2 Out Mixer", NAU8822_POWER_MANAGEMENT_1,
+        6, 0, nau8822_aux2_out_mixer),
+
+        /////////////////////////////
+	SND_SOC_DAPM_MICBIAS("Mic Bias", NAU8822_POWER_MANAGEMENT_1, 4, 0),
+
+	SND_SOC_DAPM_INPUT("LMICN"),
+	SND_SOC_DAPM_INPUT("LMICP"),
+	SND_SOC_DAPM_INPUT("RMICN"),
+	SND_SOC_DAPM_INPUT("RMICP"),
+	SND_SOC_DAPM_INPUT("LAUX"),
+	SND_SOC_DAPM_INPUT("RAUX"),
+	SND_SOC_DAPM_INPUT("L2"),
+	SND_SOC_DAPM_INPUT("R2"),
+	SND_SOC_DAPM_OUTPUT("LHP"),
+	SND_SOC_DAPM_OUTPUT("RHP"),
+	SND_SOC_DAPM_OUTPUT("LSPK"),
+	SND_SOC_DAPM_OUTPUT("RSPK"),
+        SND_SOC_DAPM_OUTPUT("AUX1OUT"),
+        SND_SOC_DAPM_OUTPUT("AUX2OUT"),
+};
+
+static const struct snd_soc_dapm_route nau8822_dapm_routes[] = {
+	/* Output mixer */
+	{"Right Output Mixer", "PCM Playback Switch", "Right DAC"},
+	{"Right Output Mixer", "Aux Playback Switch", "RAUX"},
+	{"Right Output Mixer", "Line Bypass Switch", "Right Boost Mixer"},
+
+	{"Left Output Mixer", "PCM Playback Switch", "Left DAC"},
+	{"Left Output Mixer", "Aux Playback Switch", "LAUX"},
+	{"Left Output Mixer", "Line Bypass Switch", "Left Boost Mixer"},
+
+	/* Outputs */
+	{"Right Headphone Out", NULL, "Right Output Mixer"},
+	{"RHP", NULL, "Right Headphone Out"},
+
+	{"Left Headphone Out", NULL, "Left Output Mixer"},
+	{"LHP", NULL, "Left Headphone Out"},
+
+	{"Right Speaker Out", NULL, "Right Output Mixer"},
+	{"RSPK", NULL, "Right Speaker Out"},
+
+	{"Left Speaker Out", NULL, "Left Output Mixer"},
+	{"LSPK", NULL, "Left Speaker Out"},
+
+		///////////// [destnation] <-> [control] <-> [source]
+		{"Aux1 Out Mixer", "Left Output Mixer Switch", "Left Output Mixer"},
+		{"Aux1 Out Mixer", "Right Output Mixer Switch", "Right Output Mixer"},
+		{"Aux1 Out Mixer", "Left DAC Switch", "Left DAC"},
+		{"Aux1 Out Mixer", "Right DAC Switch", "Right DAC"},
+		{"Aux1 Out Mixer", "Right RADC Mix/Boost Switch", "Right Boost Mixer"},
+		{"Aux1 Out", NULL, "Aux1 Out Mixer"},
+		{"AUX1OUT", NULL, "Aux1 Out"},
+
+
+        {"Aux2 Out Mixer", "Left Output Mixer Switch", "Left Output Mixer"},
+        {"Aux2 Out Mixer", "Left DAC Switch", "Left DAC"},
+        {"Aux2 Out Mixer", "Left RADC Mix/Boost Switch", "Left Boost Mixer"},
+        {"Aux2 Out Mixer", "Aux1 Mixer Switch", "Aux1 Out Mixer"},
+        {"Aux2 Out", NULL, "Aux2 Out Mixer"},
+        {"AUX2OUT", NULL, "Aux2 Out"},
+
+		////////////
+
+	/* Boost Mixer */
+	{"Right ADC", NULL, "Right Boost Mixer"},
+
+	{"Right Boost Mixer", NULL, "RAUX"},
+	{"Right Boost Mixer", NULL, "Right Capture PGA"},
+	{"Right Boost Mixer", NULL, "R2"},
+
+	{"Left ADC", NULL, "Left Boost Mixer"},
+
+	{"Left Boost Mixer", NULL, "LAUX"},
+	{"Left Boost Mixer", NULL, "Left Capture PGA"},
+	{"Left Boost Mixer", NULL, "L2"},
+
+	/* Input PGA */
+	{"Right Capture PGA", NULL, "Right Input Mixer"},
+	{"Left Capture PGA", NULL, "Left Input Mixer"},
+
+	{"Right Input Mixer", "R2 Switch", "R2"},
+	{"Right Input Mixer", "MicN Switch", "RMICN"},
+	{"Right Input Mixer", "MicP Switch", "RMICP"},
+
+	{"Left Input Mixer", "L2 Switch", "L2"},
+	{"Left Input Mixer", "MicN Switch", "LMICN"},
+	{"Left Input Mixer", "MicP Switch", "LMICP"},
+};
+
+/* PLL divisors */
+struct nau8822_pll_div {
+	u32 k;
+	u8 n;
+	u8 div2;
+};
+
+#define FIXED_PLL_SIZE (1 << 24)
+
+static void pll_factors(struct snd_soc_codec *codec,
+		struct nau8822_pll_div *pll_div, unsigned int target, unsigned int source)
+{
+	u64 k_part;
+	unsigned int k, n_div, n_mod;
+
+	n_div = target / source;
+	if (n_div < 6) {
+		source >>= 1;
+		pll_div->div2 = 1;
+		n_div = target / source;
+	} else {
+		pll_div->div2 = 0;
+	}
+
+	if (n_div < 6 || n_div > 12)
+		dev_warn(codec->dev,
+			 "NAU8822 N value exceeds recommended range! N = %u\n",
+			 n_div);
+
+	pll_div->n = n_div;
+	n_mod = target - source * n_div;
+	k_part = FIXED_PLL_SIZE * (long long)n_mod + source / 2;
+
+	do_div(k_part, source);
+
+	k = k_part & 0xFFFFFFFF;
+
+	pll_div->k = k;
+//	pll_div->div2 = 0;
+}
+
+/* MCLK dividers */
+static const int mclk_numerator[]	= {1, 3, 2, 3, 4, 6, 8, 12};
+static const int mclk_denominator[]	= {1, 2, 1, 1, 1, 1, 1, 1};
+
+/*
+ * find index >= idx, such that, for a given f_out,
+ * 3 * f_mclk / 4 <= f_PLLOUT < 13 * f_mclk / 4
+ * f_out can be f_256fs or f_opclk, currently only used for f_256fs. Can be
+ * generalised for f_opclk with suitable coefficient arrays, but currently
+ * the OPCLK divisor is calculated directly, not iteratively.
+ */
+static int nau8822_enum_mclk(unsigned int f_out, unsigned int f_mclk,
+			    unsigned int *f_pllout)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mclk_numerator); i++) {
+		unsigned int f_pllout_x4 = 4 * f_out * mclk_numerator[i] /
+			mclk_denominator[i];
+		if (3 * f_mclk <= f_pllout_x4 && f_pllout_x4 < 13 * f_mclk) {
+			*f_pllout = f_pllout_x4 / 4;
+			return i;
+		}
+	}
+
+	return -EINVAL;
+}
+
+/*
+ * Calculate internal frequencies and dividers, according to Figure 40
+ * "PLL and Clock Select Circuit" in NAU8822 datasheet Rev. 2.6
+ */
+static int nau8822_configure_pll(struct snd_soc_codec *codec)
+{
+	struct nau8822_priv *nau8822 = snd_soc_codec_get_drvdata(codec);
+	struct nau8822_pll_div pll_div;
+	unsigned int f_opclk = nau8822->f_opclk, f_mclk = nau8822->f_mclk,
+		f_256fs = nau8822->f_256fs;
+	unsigned int f2;
+
+	if (!f_mclk)
+		return -EINVAL;
+
+	if (f_opclk) {
+		unsigned int opclk_div;
+		/* Cannot set up MCLK divider now, do later */
+		nau8822->mclk_idx = -1;
+
+		/*
+		 * The user needs OPCLK. Choose OPCLKDIV to put
+		 * 6 <= R = f2 / f1 < 13, 1 <= OPCLKDIV <= 4.
+		 * f_opclk = f_mclk * prescale * R / 4 / OPCLKDIV, where
+		 * prescale = 1, or prescale = 2. Prescale is calculated inside
+		 * pll_factors(). We have to select f_PLLOUT, such that
+		 * f_mclk * 3 / 4 <= f_PLLOUT < f_mclk * 13 / 4. Must be
+		 * f_mclk * 3 / 16 <= f_opclk < f_mclk * 13 / 4.
+		 */
+		if (16 * f_opclk < 3 * f_mclk || 4 * f_opclk >= 13 * f_mclk)
+			return -EINVAL;
+
+		if (4 * f_opclk < 3 * f_mclk)
+			/* Have to use OPCLKDIV */
+			opclk_div = (3 * f_mclk / 4 + f_opclk - 1) / f_opclk;
+		else
+			opclk_div = 1;
+
+		dev_dbg(codec->dev, "%s: OPCLKDIV=%d\n", __func__, opclk_div);
+
+		snd_soc_update_bits(codec, NAU8822_GPIO_CONTROL, 0x30,
+				    (opclk_div - 1) << 4);
+
+		nau8822->f_pllout = f_opclk * opclk_div;
+	} else if (f_256fs) {
+		/*
+		 * Not using OPCLK, but PLL is used for the codec, choose R:
+		 * 6 <= R = f2 / f1 < 13, to put 1 <= MCLKDIV <= 12.
+		 * f_256fs = f_mclk * prescale * R / 4 / MCLKDIV, where
+		 * prescale = 1, or prescale = 2. Prescale is calculated inside
+		 * pll_factors(). We have to select f_PLLOUT, such that
+		 * f_mclk * 3 / 4 <= f_PLLOUT < f_mclk * 13 / 4. Must be
+		 * f_mclk * 3 / 48 <= f_256fs < f_mclk * 13 / 4. This means MCLK
+		 * must be 3.781MHz <= f_MCLK <= 32.768MHz
+		 */
+		int idx = nau8822_enum_mclk(f_256fs, f_mclk, &nau8822->f_pllout);
+		if (idx < 0)
+			return idx;
+
+		nau8822->mclk_idx = idx;
+	} else {
+		return -EINVAL;
+	}
+
+	f2 = nau8822->f_pllout * 4;
+
+	dev_dbg(codec->dev, "%s: f_MCLK=%uHz, f_PLLOUT=%uHz\n", __func__,
+		nau8822->f_mclk, nau8822->f_pllout);
+
+	pll_factors(codec, &pll_div, f2, nau8822->f_mclk);
+
+	dev_dbg(codec->dev, "%s: calculated PLL N=0x%x, K=0x%x, div2=%d\n",
+		__func__, pll_div.n, pll_div.k, pll_div.div2);
+
+	/* Turn PLL off for configuration... */
+	snd_soc_update_bits(codec, NAU8822_POWER_MANAGEMENT_1, 0x20, 0);
+
+	snd_soc_write(codec, NAU8822_PLL_N, (pll_div.div2 << 4) | pll_div.n);
+	snd_soc_write(codec, NAU8822_PLL_K1, pll_div.k >> 18);
+	snd_soc_write(codec, NAU8822_PLL_K2, (pll_div.k >> 9) & 0x1ff);
+	snd_soc_write(codec, NAU8822_PLL_K3, pll_div.k & 0x1ff);
+
+	/* ...and on again */
+	snd_soc_update_bits(codec, NAU8822_POWER_MANAGEMENT_1, 0x20, 0x20);
+
+	if (f_opclk)
+		/* Output PLL (OPCLK) to GPIO1 */
+		snd_soc_update_bits(codec, NAU8822_GPIO_CONTROL, 7, 4);
+
+	return 0;
+}
+
+/*
+ * Configure NAU8822 clock dividers.
+ */
+static int nau8822_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
+				 int div_id, int div)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct nau8822_priv *nau8822 = snd_soc_codec_get_drvdata(codec);
+	int ret = 0;
+
+	switch (div_id) {
+	case NAU8822_OPCLKRATE:
+		nau8822->f_opclk = div;
+
+		if (nau8822->f_mclk)
+			/*
+			 * We know the MCLK frequency, the user has requested
+			 * OPCLK, configure the PLL based on that and start it
+			 * and OPCLK immediately. We will configure PLL to match
+			 * user-requested OPCLK frquency as good as possible.
+			 * In fact, it is likely, that matching the sampling
+			 * rate, when it becomes known, is more important, and
+			 * we will not be reconfiguring PLL then, because we
+			 * must not interrupt OPCLK. But it should be fine,
+			 * because typically the user will request OPCLK to run
+			 * at 256fs or 512fs, and for these cases we will also
+			 * find an exact MCLK divider configuration - it will
+			 * be equal to or double the OPCLK divisor.
+			 */
+			ret = nau8822_configure_pll(codec);
+		break;
+	case NAU8822_BCLKDIV:
+		if (div & ~0x1c)
+			return -EINVAL;
+		snd_soc_update_bits(codec, NAU8822_CLOCKING, 0x1c, div);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dev_dbg(codec->dev, "%s: ID %d, value %u\n", __func__, div_id, div);
+
+	return ret;
+}
+
+/*
+ * @freq:	when .set_pll() us not used, freq is codec MCLK input frequency
+ */
+static int nau8822_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id,
+				 unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct nau8822_priv *nau8822 = snd_soc_codec_get_drvdata(codec);
+	int ret = 0;
+
+	dev_dbg(codec->dev, "%s: ID %d, freq %u\n", __func__, clk_id, freq);
+
+	if (freq) {
+		nau8822->f_mclk = freq;
+
+		/* Even if MCLK is used for system clock, might have to drive OPCLK */
+		if (nau8822->f_opclk)
+			ret = nau8822_configure_pll(codec);
+
+		/* Our sysclk is fixed to 256 * fs, will configure in .hw_params()  */
+
+		if (!ret)
+			nau8822->sysclk = clk_id;
+	}
+
+	if (nau8822->sysclk == NAU8822_PLL && (!freq || clk_id == NAU8822_MCLK)) {
+		/* Clock CODEC directly from MCLK */
+		snd_soc_update_bits(codec, NAU8822_CLOCKING, 0x100, 0);
+
+		/* GPIO1 into default mode as input - before configuring PLL */
+		snd_soc_update_bits(codec, NAU8822_GPIO_CONTROL, 7, 0);
+
+		/* Turn off PLL */
+		snd_soc_update_bits(codec, NAU8822_POWER_MANAGEMENT_1, 0x20, 0);
+		nau8822->sysclk = NAU8822_MCLK;
+		nau8822->f_pllout = 0;
+		nau8822->f_opclk = 0;
+	}
+
+	return ret;
+}
+
+/*
+ * Set ADC and Voice DAC format.
+ */
+static int nau8822_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	/*
+	 * BCLK polarity mask = 0x100, LRC clock polarity mask = 0x80,
+	 * Data Format mask = 0x18: all will be calculated anew
+	 */
+	u16 iface = snd_soc_read(codec, NAU8822_AUDIO_INTERFACE) & ~0x198;
+	u16 clk = snd_soc_read(codec, NAU8822_CLOCKING);
+
+	dev_dbg(codec->dev, "%s\n", __func__);
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		clk |= 1;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		clk &= ~1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x10;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x8;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x18;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x180;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x100;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x80;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	snd_soc_write(codec, NAU8822_AUDIO_INTERFACE, iface);
+	snd_soc_write(codec, NAU8822_CLOCKING, clk);
+
+	return 0;
+}
+
+/*
+ * Set PCM DAI bit size and sample rate.
+ */
+static int nau8822_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct nau8822_priv *nau8822 = snd_soc_codec_get_drvdata(codec);
+	/* Word length mask = 0x60 */
+	u16 iface_ctl = snd_soc_read(codec, NAU8822_AUDIO_INTERFACE) & ~0x60;
+	/* Sampling rate mask = 0xe (for filters) */
+	u16 add_ctl = snd_soc_read(codec, NAU8822_ADDITIONAL_CONTROL) & ~0xe;
+	u16 clking = snd_soc_read(codec, NAU8822_CLOCKING);
+	enum nau8822_sysclk_src current_clk_id = clking & 0x100 ?
+		NAU8822_PLL : NAU8822_MCLK;
+	unsigned int f_sel, diff, diff_best = INT_MAX;
+	int i, best = 0;
+
+	if (!nau8822->f_mclk)
+		return -EINVAL;
+
+	/* bit size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		iface_ctl |= 0x20;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		iface_ctl |= 0x40;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		iface_ctl |= 0x60;
+		break;
+	}
+
+	/* filter coefficient */
+	switch (params_rate(params)) {
+	case 8000:
+		add_ctl |= 0x5 << 1;
+		break;
+	case 11025:
+		add_ctl |= 0x4 << 1;
+		break;
+	case 16000:
+		add_ctl |= 0x3 << 1;
+		break;
+	case 22050:
+		add_ctl |= 0x2 << 1;
+		break;
+	case 32000:
+		add_ctl |= 0x1 << 1;
+		break;
+	case 44100:
+	case 48000:
+		break;
+	}
+
+	/* Sampling rate is known now, can configure the MCLK divider */
+	nau8822->f_256fs = params_rate(params) * 256;
+
+	if (nau8822->sysclk == NAU8822_MCLK) {
+		nau8822->mclk_idx = -1;
+		f_sel = nau8822->f_mclk;
+	} else {
+		if (!nau8822->f_opclk) {
+			/* We only enter here, if OPCLK is not used */
+			int ret = nau8822_configure_pll(codec);
+			if (ret < 0)
+				return ret;
+		}
+		f_sel = nau8822->f_pllout;
+	}
+
+	if (nau8822->mclk_idx < 0) {
+		/* Either MCLK is used directly, or OPCLK is used */
+		if (f_sel < nau8822->f_256fs || f_sel > 12 * nau8822->f_256fs)
+			return -EINVAL;
+
+		for (i = 0; i < ARRAY_SIZE(mclk_numerator); i++) {
+			diff = abs(nau8822->f_256fs * 3 -
+				   f_sel * 3 * mclk_denominator[i] / mclk_numerator[i]);
+
+			if (diff < diff_best) {
+				diff_best = diff;
+				best = i;
+			}
+
+			if (!diff)
+				break;
+		}
+	} else {
+		/* OPCLK not used, codec driven by PLL */
+		best = nau8822->mclk_idx;
+		diff = 0;
+	}
+
+	if (diff)
+		dev_warn(codec->dev, "Imprecise sampling rate: %uHz%s\n",
+			f_sel * mclk_denominator[best] / mclk_numerator[best] / 256,
+			nau8822->sysclk == NAU8822_MCLK ?
+			", consider using PLL" : "");
+
+	dev_dbg(codec->dev, "%s: fmt %d, rate %u, MCLK divisor #%d\n", __func__,
+		params_format(params), params_rate(params), best);
+
+	/* MCLK divisor mask = 0xe0 */
+	snd_soc_update_bits(codec, NAU8822_CLOCKING, 0xe0, best << 5);
+
+	snd_soc_write(codec, NAU8822_AUDIO_INTERFACE, iface_ctl);
+	snd_soc_write(codec, NAU8822_ADDITIONAL_CONTROL, add_ctl);
+
+	if (nau8822->sysclk != current_clk_id) {
+		if (nau8822->sysclk == NAU8822_PLL)
+			/* Run CODEC from PLL instead of MCLK */
+			snd_soc_update_bits(codec, NAU8822_CLOCKING,
+					    0x100, 0x100);
+		else
+			/* Clock CODEC directly from MCLK */
+			snd_soc_update_bits(codec, NAU8822_CLOCKING, 0x100, 0);
+	}
+
+	return 0;
+}
+
+static int nau8822_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	dev_dbg(codec->dev, "%s: %d\n", __func__, mute);
+
+	if (mute)
+		snd_soc_update_bits(codec, NAU8822_DAC_CONTROL, 0x40, 0x40);
+	else
+		snd_soc_update_bits(codec, NAU8822_DAC_CONTROL, 0x40, 0);
+
+	return 0;
+}
+
+static int nau8822_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	u16 power1 = snd_soc_read(codec, NAU8822_POWER_MANAGEMENT_1) & ~3;
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+	case SND_SOC_BIAS_PREPARE:
+		power1 |= 1;  /* VMID 75k */
+		snd_soc_write(codec, NAU8822_POWER_MANAGEMENT_1, power1);
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		/* bit 3: enable bias, bit 2: enable I/O tie off buffer */
+		power1 |= 0xc;
+
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
+			/* Initial cap charge at VMID 5k */
+			snd_soc_write(codec, NAU8822_POWER_MANAGEMENT_1,
+				      power1 | 0x3);
+			mdelay(100);
+		}
+
+		power1 |= 0x2;  /* VMID 500k */
+		snd_soc_write(codec, NAU8822_POWER_MANAGEMENT_1, power1);
+		break;
+	case SND_SOC_BIAS_OFF:
+		/* Preserve PLL - OPCLK may be used by someone */
+		snd_soc_update_bits(codec, NAU8822_POWER_MANAGEMENT_1, ~0x20, 0);
+		snd_soc_write(codec, NAU8822_POWER_MANAGEMENT_2, 0);
+		snd_soc_write(codec, NAU8822_POWER_MANAGEMENT_3, 0);
+		break;
+	}
+
+	dev_dbg(codec->dev, "%s: %d, %x\n", __func__, level, power1);
+
+	//codec->dapm.bias_level = level;
+	return 0;
+}
+
+#define NAU8822_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+static const struct snd_soc_dai_ops nau8822_dai_ops = {
+	.hw_params	= nau8822_hw_params,
+	.digital_mute	= nau8822_mute,
+	.set_fmt	= nau8822_set_dai_fmt,
+	.set_clkdiv	= nau8822_set_dai_clkdiv,
+	.set_sysclk	= nau8822_set_dai_sysclk,
+};
+
+/* Also supports 12kHz */
+static struct snd_soc_dai_driver nau8822_dai = {
+	.name = "nau8822-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+		.formats = NAU8822_FORMATS,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+		.formats = NAU8822_FORMATS,
+	},
+	.ops = &nau8822_dai_ops,
+};
+
+static int nau8822_suspend(struct snd_soc_codec *codec)
+{
+	struct nau8822_priv *nau8822 = snd_soc_codec_get_drvdata(codec);
+
+	nau8822_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	/* Also switch PLL off */
+	snd_soc_write(codec, NAU8822_POWER_MANAGEMENT_1, 0);
+
+	regcache_mark_dirty(nau8822->regmap);
+
+	return 0;
+}
+
+static int nau8822_resume(struct snd_soc_codec *codec)
+{
+	struct nau8822_priv *nau8822 = snd_soc_codec_get_drvdata(codec);
+
+	/* Sync reg_cache with the hardware */
+	regcache_sync(nau8822->regmap);
+
+	nau8822_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	if (nau8822->f_pllout)
+		/* Switch PLL on */
+		snd_soc_update_bits(codec, NAU8822_POWER_MANAGEMENT_1, 0x20, 0x20);
+
+	return 0;
+}
+
+/*
+ * These registers contain an "update" bit - bit 8. This means, for example,
+ * that one can write new DAC digital volume for both channels, but only when
+ * the update bit is set, will also the volume be updated - simultaneously for
+ * both channels.
+ */
+static const int update_reg[] = {
+	NAU8822_LEFT_DAC_DIGITAL_VOLUME,
+	NAU8822_RIGHT_DAC_DIGITAL_VOLUME,
+	NAU8822_LEFT_ADC_DIGITAL_VOLUME,
+	NAU8822_RIGHT_ADC_DIGITAL_VOLUME,
+	NAU8822_LEFT_INP_PGA_CONTROL,
+	NAU8822_RIGHT_INP_PGA_CONTROL,
+	NAU8822_LOUT1_HP_CONTROL,
+	NAU8822_ROUT1_HP_CONTROL,
+	NAU8822_LOUT2_SPK_CONTROL,
+	NAU8822_ROUT2_SPK_CONTROL,
+};
+
+static int nau8822_probe(struct snd_soc_codec *codec)
+{
+	struct nau8822_priv *nau8822 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	int i;
+
+	nau8822->dapm = dapm;
+
+	/*
+	 * Set default system clock to PLL, it is more precise, this is also the
+	 * default hardware setting
+	 */
+	nau8822->sysclk = NAU8822_PLL;
+
+	/*
+	 * Set the update bit in all registers, that have one. This way all
+	 * writes to those registers will also cause the update bit to be
+	 * written.
+	 */
+	for (i = 0; i < ARRAY_SIZE(update_reg); i++)
+		snd_soc_update_bits(codec, update_reg[i], 0x100, 0x100);
+
+	nau8822_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	snd_soc_update_bits(codec, NAU8822_BEEP_CONTROL, 0x10, 0x10);
+
+	return 0;
+}
+
+/* power down chip */
+static int nau8822_remove(struct snd_soc_codec *codec)
+{
+	nau8822_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_nau8822 = {
+	.probe =	nau8822_probe,
+	.remove =	nau8822_remove,
+	.suspend =	nau8822_suspend,
+	.resume =	nau8822_resume,
+	.set_bias_level = nau8822_set_bias_level,
+
+	.controls = nau8822_snd_controls,
+	.num_controls = ARRAY_SIZE(nau8822_snd_controls),
+	.dapm_widgets = nau8822_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(nau8822_dapm_widgets),
+	.dapm_routes = nau8822_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(nau8822_dapm_routes),
+};
+
+static const struct regmap_config nau8822_regmap_config = {
+	.val_bits = 9,
+	.reg_bits = 7,
+
+	.max_register = NAU8822_MAX_REGISTER,
+	.volatile_reg = nau8822_volatile,
+
+	.cache_type = REGCACHE_RBTREE,
+	.reg_defaults = nau8822_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(nau8822_reg_defaults),
+};
+
+static int nau8822_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct nau8822_priv *nau8822;
+	int ret;
+
+	nau8822 = devm_kzalloc(&i2c->dev, sizeof(struct nau8822_priv),
+			      GFP_KERNEL);
+	if (nau8822 == NULL)
+		return -ENOMEM;
+
+	nau8822->regmap = devm_regmap_init_i2c(i2c, &nau8822_regmap_config);
+	if (IS_ERR(nau8822->regmap)) {
+		ret = PTR_ERR(nau8822->regmap);
+		dev_err(&i2c->dev, "Failed to allocate regmap: %d\n", ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(i2c, nau8822);
+
+	/* Reset the codec */
+	ret = regmap_write(nau8822->regmap, NAU8822_RESET, 0);
+	if (ret != 0) {
+		dev_err(&i2c->dev, "Failed to issue reset: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_register_codec(&i2c->dev,
+			&soc_codec_dev_nau8822, &nau8822_dai, 1);
+	if (ret != 0) {
+		dev_err(&i2c->dev, "Failed to register CODEC: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nau8822_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id nau8822_i2c_id[] = {
+	{ "nau8822", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, nau8822_i2c_id);
+
+#if defined(CONFIG_OF)
+static const struct of_device_id nau8822_of_match[] = {
+    { .compatible = "nuvoton,nau8822", },
+	{ }
+};
+#endif
+
+static struct i2c_driver nau8822_i2c_driver = {
+	.driver = {
+		.name = "nau8822",
+		.owner = THIS_MODULE,
+#if defined(CONFIG_OF)
+        .of_match_table = of_match_ptr(nau8822_of_match),
+#endif
+	},
+	.probe =    nau8822_i2c_probe,
+	.remove =   nau8822_i2c_remove,
+	.id_table = nau8822_i2c_id,
+};
+
+module_i2c_driver(nau8822_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC NAU8822 codec driver");
+MODULE_AUTHOR("Guennadi Liakhovetski <g.liakhovetski@gmx.de>");
+MODULE_LICENSE("GPL");
diff -uprN linux-4.4.194/sound/soc/codecs/nau8822.h NUC980-linux-4.4.194/sound/soc/codecs/nau8822.h
--- linux-4.4.194/sound/soc/codecs/nau8822.h	1969-12-31 16:00:00.000000000 -0800
+++ NUC980-linux-4.4.194/sound/soc/codecs/nau8822.h	2019-12-29 19:12:21.000000000 -0800
@@ -0,0 +1,85 @@
+/*
+ * nau8822.h		--  codec driver for NAU8822
+ *
+ * Copyright 2009 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __NAU8822_H__
+#define __NAU8822_H__
+
+/*
+ * Register values.
+ */
+#define NAU8822_RESET					0x00
+#define NAU8822_POWER_MANAGEMENT_1		0x01
+#define NAU8822_POWER_MANAGEMENT_2		0x02
+#define NAU8822_POWER_MANAGEMENT_3		0x03
+#define NAU8822_AUDIO_INTERFACE			0x04
+#define NAU8822_COMPANDING_CONTROL		0x05
+#define NAU8822_CLOCKING				0x06
+#define NAU8822_ADDITIONAL_CONTROL		0x07
+#define NAU8822_GPIO_CONTROL			0x08
+#define NAU8822_JACK_DETECT_CONTROL_1	0x09
+#define NAU8822_DAC_CONTROL				0x0A
+#define NAU8822_LEFT_DAC_DIGITAL_VOLUME		0x0B
+#define NAU8822_RIGHT_DAC_DIGITAL_VOLUME	0x0C
+#define NAU8822_JACK_DETECT_CONTROL_2		0x0D
+#define NAU8822_ADC_CONTROL				0x0E
+#define NAU8822_LEFT_ADC_DIGITAL_VOLUME		0x0F
+#define NAU8822_RIGHT_ADC_DIGITAL_VOLUME	0x10
+#define NAU8822_EQ1				0x12
+#define NAU8822_EQ2				0x13
+#define NAU8822_EQ3				0x14
+#define NAU8822_EQ4				0x15
+#define NAU8822_EQ5				0x16
+#define NAU8822_DAC_LIMITER_1			0x18
+#define NAU8822_DAC_LIMITER_2			0x19
+#define NAU8822_NOTCH_FILTER_1			0x1b
+#define NAU8822_NOTCH_FILTER_2			0x1c
+#define NAU8822_NOTCH_FILTER_3			0x1d
+#define NAU8822_NOTCH_FILTER_4			0x1e
+#define NAU8822_ALC_CONTROL_1			0x20
+#define NAU8822_ALC_CONTROL_2			0x21
+#define NAU8822_ALC_CONTROL_3			0x22
+#define NAU8822_NOISE_GATE			0x23
+#define NAU8822_PLL_N				0x24
+#define NAU8822_PLL_K1				0x25
+#define NAU8822_PLL_K2				0x26
+#define NAU8822_PLL_K3				0x27
+#define NAU8822_3D_CONTROL			0x29
+#define NAU8822_BEEP_CONTROL			0x2b
+#define NAU8822_INPUT_CONTROL			0x2c
+#define NAU8822_LEFT_INP_PGA_CONTROL		0x2d
+#define NAU8822_RIGHT_INP_PGA_CONTROL		0x2e
+#define NAU8822_LEFT_ADC_BOOST_CONTROL		0x2f
+#define NAU8822_RIGHT_ADC_BOOST_CONTROL		0x30
+#define NAU8822_OUTPUT_CONTROL			0x31
+#define NAU8822_LEFT_MIXER_CONTROL		0x32
+#define NAU8822_RIGHT_MIXER_CONTROL		0x33
+#define NAU8822_LOUT1_HP_CONTROL			0x34
+#define NAU8822_ROUT1_HP_CONTROL			0x35
+#define NAU8822_LOUT2_SPK_CONTROL		0x36
+#define NAU8822_ROUT2_SPK_CONTROL		0x37
+#define NAU8822_OUT3_MIXER_CONTROL		0x38
+#define NAU8822_OUT4_MIXER_CONTROL		0x39
+
+#define NAU8822_MAX_REGISTER			0x39
+
+#define NAU8822_CACHEREGNUM			58
+
+/* Clock divider Id's */
+enum nau8822_clk_id {
+	NAU8822_OPCLKRATE,
+	NAU8822_BCLKDIV,
+};
+
+enum nau8822_sysclk_src {
+	NAU8822_PLL,
+	NAU8822_MCLK
+};
+
+#endif	/* __NAU8822_H__ */
diff -uprN linux-4.4.194/sound/soc/Kconfig NUC980-linux-4.4.194/sound/soc/Kconfig
--- linux-4.4.194/sound/soc/Kconfig	2019-09-20 22:12:54.000000000 -0700
+++ NUC980-linux-4.4.194/sound/soc/Kconfig	2019-12-29 19:12:21.000000000 -0800
@@ -48,6 +48,7 @@ source "sound/soc/dwc/Kconfig"
 source "sound/soc/fsl/Kconfig"
 source "sound/soc/jz4740/Kconfig"
 source "sound/soc/nuc900/Kconfig"
+source "sound/soc/nuc980/Kconfig"
 source "sound/soc/omap/Kconfig"
 source "sound/soc/kirkwood/Kconfig"
 source "sound/soc/intel/Kconfig"
diff -uprN linux-4.4.194/sound/soc/Makefile NUC980-linux-4.4.194/sound/soc/Makefile
--- linux-4.4.194/sound/soc/Makefile	2019-09-20 22:12:54.000000000 -0700
+++ NUC980-linux-4.4.194/sound/soc/Makefile	2019-12-29 19:12:21.000000000 -0800
@@ -31,6 +31,7 @@ obj-$(CONFIG_SND_SOC)	+= intel/
 obj-$(CONFIG_SND_SOC)	+= mediatek/
 obj-$(CONFIG_SND_SOC)	+= mxs/
 obj-$(CONFIG_SND_SOC)	+= nuc900/
+obj-$(CONFIG_SND_SOC)	+= nuc980/
 obj-$(CONFIG_SND_SOC)	+= omap/
 obj-$(CONFIG_SND_SOC)	+= kirkwood/
 obj-$(CONFIG_SND_SOC)	+= pxa/
diff -uprN linux-4.4.194/sound/soc/nuc980/Kconfig NUC980-linux-4.4.194/sound/soc/nuc980/Kconfig
--- linux-4.4.194/sound/soc/nuc980/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ NUC980-linux-4.4.194/sound/soc/nuc980/Kconfig	2019-12-29 19:12:21.000000000 -0800
@@ -0,0 +1,43 @@
+##
+## NUC980 series I2S API
+##
+config SND_SOC_NUC980
+	tristate "SoC Audio for NUC980 series"
+	depends on ARCH_NUC980
+	help
+	  This option enables support for I2S on the NUC980 SoC.
+
+##
+## Boards
+##
+config SND_SOC_NUC980EVB
+	tristate "NUC980 I2S support for demo board"
+	depends on SND_SOC_NUC980
+	select SND_SOC_NAU8822
+	help
+	  Select this option to enable audio (I2S) on the
+	  NUC980 demoboard.
+
+choice
+	prompt "I2S Mode Selection"
+	depends on SND_SOC_NUC980EVB
+	default SLAVE_MODE
+
+config NUC980_I2S_MASTER_MODE
+	bool "Master Mode"
+
+config NUC980_I2S_SLAVE_MODE
+	bool "Slave Mode"
+
+endchoice
+
+choice
+	prompt "NUC980 I2S pin selection"
+	default NUC980_I2S_PA
+	depends on SND_SOC_NUC980EVB
+
+config NUC980_I2S_PA
+	bool "Port A"
+config NUC980_I2S_PB
+	bool "Port B"
+endchoice
diff -uprN linux-4.4.194/sound/soc/nuc980/Makefile NUC980-linux-4.4.194/sound/soc/nuc980/Makefile
--- linux-4.4.194/sound/soc/nuc980/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ NUC980-linux-4.4.194/sound/soc/nuc980/Makefile	2019-12-29 19:12:21.000000000 -0800
@@ -0,0 +1,10 @@
+# NUC980 series audio
+snd-soc-nuc980-pcm-objs := nuc980-pcm.o
+snd-soc-nuc980-i2s-objs := nuc980-i2s.o
+
+obj-$(CONFIG_SND_SOC_NUC980) += snd-soc-nuc980-pcm.o nuc980-i2s.o
+
+# Boards
+snd-soc-nuc980-audio-objs := nuc980-audio.o
+
+obj-$(CONFIG_SND_SOC_NUC980EVB) += snd-soc-nuc980-audio.o
diff -uprN linux-4.4.194/sound/soc/nuc980/nuc980-audio.c NUC980-linux-4.4.194/sound/soc/nuc980/nuc980-audio.c
--- linux-4.4.194/sound/soc/nuc980/nuc980-audio.c	1969-12-31 16:00:00.000000000 -0800
+++ NUC980-linux-4.4.194/sound/soc/nuc980/nuc980-audio.c	2019-12-29 19:12:21.000000000 -0800
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2018 Nuvoton technology corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+
+#include "nuc980-audio.h"
+#include "../codecs/nau8822.h"
+
+static int nuc980_audio_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret;
+
+//slave mode
+#ifdef CONFIG_NUC980_I2S_SLAVE_MODE
+	 /* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, NAU8822_PLL, 12000000, SND_SOC_CLOCK_OUT);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(codec_dai, NAU8822_BCLKDIV, 0xC);          // divide 8 form MCLK to BCLK
+	if (ret < 0)
+		return ret;
+#else
+//master mode
+	unsigned int clk = 0;
+	unsigned int sample_rate = params_rate(params);
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		return ret;
+
+	clk = 256 * sample_rate;
+	cpu_dai->channels = params_channels(params);
+	cpu_dai->rate = params_rate(params);
+	cpu_dai->sample_bits = params_width(params);
+
+	/* set the codec system clock for DAC and ADC */
+	ret = snd_soc_dai_set_sysclk(codec_dai, NAU8822_MCLK, clk, SND_SOC_CLOCK_OUT);
+	if (ret < 0)
+		return ret;
+
+	/* set prescaler division for sample rate */
+	ret =snd_soc_dai_set_sysclk(cpu_dai, NUC980_AUDIO_CLKDIV, sample_rate, SND_SOC_CLOCK_OUT);
+	if (ret < 0)
+		return ret;
+
+	/* set MCLK division for sample rate */
+	ret = snd_soc_dai_set_sysclk(cpu_dai, NUC980_AUDIO_SAMPLECLK, sample_rate, SND_SOC_CLOCK_OUT);
+	if (ret < 0)
+		return ret;
+#endif
+	return 0;
+}
+
+static struct snd_soc_ops nuc980_audio_ops = {
+	.hw_params = nuc980_audio_hw_params,
+};
+
+static struct snd_soc_dai_link nuc980evb_i2s_dai = {
+	.name               =   "IIS",
+	.stream_name        =   "IIS HiFi",
+	.cpu_dai_name       =   "nuc980-audio-i2s",
+	.codec_dai_name     =   "nau8822-hifi",
+	.codec_name         =   "nau8822.0-001a",
+	.ops                =   &nuc980_audio_ops,
+	.platform_name      =   "nuc980-audio-pcm.0",
+};
+
+static struct snd_soc_card nuc980evb_audio_machine = {
+	.name       =   "nuc980_IIS",
+	.owner      =   THIS_MODULE,
+	.dai_link   =   &nuc980evb_i2s_dai,
+	.num_links  =   1,
+};
+
+static int nuc980_audio_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_card *card = &nuc980evb_audio_machine;
+	int ret;
+
+	card->dev = &pdev->dev;
+
+	if (np) {
+		nuc980evb_i2s_dai.cpu_dai_name = NULL;
+		nuc980evb_i2s_dai.cpu_of_node = of_parse_phandle(np, "i2s-controller", 0);
+		if (!nuc980evb_i2s_dai.cpu_of_node) {
+			dev_err(&pdev->dev, "Property 'i2s-controller' missing or invalid\n");
+			ret = -EINVAL;
+		}
+
+		nuc980evb_i2s_dai.platform_name = NULL;
+		nuc980evb_i2s_dai.platform_of_node = of_parse_phandle(np, "i2s-platform", 0);
+		if (!nuc980evb_i2s_dai.platform_of_node) {
+			dev_err(&pdev->dev, "Property 'i2s-platform' missing or invalid\n");
+			ret = -EINVAL;
+		}
+	}
+
+	ret = snd_soc_register_card(card);
+	if (ret)
+		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n", ret);
+
+	return ret;
+}
+
+static int nuc980_audio_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_card(card);
+	return 0;
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id nuc980_audio_of_match[] = {
+	{ .compatible = "nuvoton,nuc980-audio" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nuc980_audio_of_match);
+#endif
+
+static struct   platform_driver nuc980_audio_driver = {
+	.driver = {
+		.name = "nuc980-audio",
+		.owner = THIS_MODULE,
+#if defined(CONFIG_OF)
+		.of_match_table = of_match_ptr(nuc980_audio_of_match),
+#endif
+	},
+	.probe = nuc980_audio_probe,
+	.remove = nuc980_audio_remove,
+};
+
+module_platform_driver(nuc980_audio_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NUC980 Series ASoC audio support");
diff -uprN linux-4.4.194/sound/soc/nuc980/nuc980-audio.h NUC980-linux-4.4.194/sound/soc/nuc980/nuc980-audio.h
--- linux-4.4.194/sound/soc/nuc980/nuc980-audio.h	1969-12-31 16:00:00.000000000 -0800
+++ NUC980-linux-4.4.194/sound/soc/nuc980/nuc980-audio.h	2019-12-29 19:12:21.000000000 -0800
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2018 Nuvoton technology corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#ifndef _NUC980_AUDIO_H
+#define _NUC980_AUDIO_H
+
+#include <linux/io.h>
+#include <mach/regs-audio.h>
+
+/* bit definition of REG_ACTL_CON register */
+#define R_DMA_IRQ_EN            0x200000
+#define P_DMA_IRQ_EN            0x100000
+
+#define R_DMA_IRQ_SEL_EIGHTH    0xC000
+#define R_DMA_IRQ_SEL_QUARTER   0x8000
+#define R_DMA_IRQ_SEL_HALF      0x4000
+#define R_DMA_IRQ_SEL_END       0x0000
+
+#define P_DMA_IRQ_SEL_EIGHTH    0x3000
+#define P_DMA_IRQ_SEL_QUARTER   0x2000
+#define P_DMA_IRQ_SEL_HALF      0x1000
+#define P_DMA_IRQ_SEL_END       0x0000
+
+#define R_DMA_IRQ               0x0800
+#define P_DMA_IRQ               0x0400
+#define BITS_SELECT_24          0x0200
+#define BITS_SELECT_16          0x0100
+#define BITS_SELECT_8           0x0000
+#define FIFO_TH                 0x0080
+#define IRQ_DMA_CNTER_EN        0x0010
+#define IRQ_DMA_DATA_ZERO_EN    0x0008
+#define PCM_EN                  0x0002
+#define I2S_EN                  0x0001
+
+
+/* bit definition of REG_ACTL_RESET register */
+#define SPLIT_DATA          0x100000
+#define ACTL_RESET_BIT      0x10000
+#define RECORD_RIGHT_CHNNEL 0x08000
+#define RECORD_LEFT_CHNNEL  0x04000
+#define PLAY_RIGHT_CHNNEL   0x02000
+#define PLAY_LEFT_CHNNEL    0x01000
+#define AUDIO_RECORD        0x00040
+#define AUDIO_PLAY          0x00020
+#define I2S_PCM_RESET       0x00001
+
+/* bit definition of ACTL_RSR register */
+#define R_FIFO_FULL         0x04
+#define R_FIFO_EMPTY        0x02
+#define R_DMA_RIA_IRQ       0x01
+
+/* bit definition of ACTL_PSR register */
+#define P_FIFO_FULL         0x04
+#define P_FIFO_EMPTY        0x02
+#define P_DMA_RIA_IRQ       0x01
+
+/*----- bit definition of REG_ACTL_I2SCON register -----*/
+#define I2S_SLAVE           0x100000
+#define FORMAT_I2S          0x0000
+#define FORMAT_MSB          0x0008
+#define MCLK_SEL            0x0010
+#define SCALE_1             0x00000
+#define SCALE_2             0x10000
+#define SCALE_3             0x20000
+#define SCALE_4             0x30000
+#define SCALE_5             0x40000
+#define SCALE_6             0x50000
+#define SCALE_7             0x60000
+#define SCALE_8             0x70000
+#define SCALE_10            0x90000
+#define SCALE_12            0xB0000
+#define SCALE_14            0xD0000
+#define SCALE_16            0xF0000
+#define FS_384              0x20
+#define FS_256              0x0
+#define BCLK_32             0x00
+#define BCLK_48             0x40
+
+#define NUC980_AUDIO_SAMPLECLK  0x00
+#define NUC980_AUDIO_CLKDIV     0x01
+
+#define CODEC_READY     0x10
+#define RESET_PRSR      0x00
+#define AUDIO_WRITE(addr, val)  __raw_writel(val, addr)
+#define AUDIO_READ(addr)    __raw_readl(addr)
+
+struct nuc980_audio {
+	void __iomem *mmio;
+	spinlock_t irqlock, lock;
+	dma_addr_t dma_addr[2];
+	unsigned long buffersize[2];
+	unsigned long irq_num;
+	struct snd_pcm_substream *substream[2];
+	struct resource *res;
+	struct clk *clk;
+	struct device *dev;
+
+};
+
+extern struct nuc980_audio *nuc980_i2s_data;
+
+int nuc980_dma_create(struct nuc980_audio *nuc980_audio);
+int nuc980_dma_destroy(struct nuc980_audio *nuc980_audio);
+#endif /*end _NUC980_AUDIO_H */
diff -uprN linux-4.4.194/sound/soc/nuc980/nuc980-i2s.c NUC980-linux-4.4.194/sound/soc/nuc980/nuc980-i2s.c
--- linux-4.4.194/sound/soc/nuc980/nuc980-i2s.c	1969-12-31 16:00:00.000000000 -0800
+++ NUC980-linux-4.4.194/sound/soc/nuc980/nuc980-i2s.c	2019-12-29 19:12:21.000000000 -0800
@@ -0,0 +1,411 @@
+/*
+ * Copyright (c) 2018 Nuvoton technology corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/suspend.h>
+#include <sound/core.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dai.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+
+#include <mach/mfp.h>
+#include <mach/map.h>
+#include <mach/regs-clock.h>
+
+#include "nuc980-audio.h"
+
+static DEFINE_MUTEX(i2s_mutex);
+struct nuc980_audio *nuc980_i2s_data;
+
+static int nuc980_i2s_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	struct nuc980_audio *nuc980_audio = nuc980_i2s_data;
+	unsigned long val = AUDIO_READ(nuc980_audio->mmio + ACTL_CON);
+
+	switch (params_width(params)) {
+		case 8:
+			val = (val & ~0x300) | BITS_SELECT_8;
+			break;
+
+		case 16:
+			val = (val & ~0x300) | BITS_SELECT_16;
+			break;
+
+		case 24:
+			val = (val & ~0x300) | BITS_SELECT_24;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+	AUDIO_WRITE(nuc980_audio->mmio + ACTL_CON, val);
+	return 0;
+}
+
+static int nuc980_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct nuc980_audio *nuc980_audio = nuc980_i2s_data;
+	unsigned long val = AUDIO_READ(nuc980_audio->mmio + ACTL_I2SCON);
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_MSB:
+			val |= FORMAT_MSB;
+			break;
+		case SND_SOC_DAIFMT_I2S:
+			val &= ~FORMAT_MSB;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+		case SND_SOC_DAIFMT_CBM_CFM:
+			val &= ~I2S_SLAVE;
+			break;
+		case SND_SOC_DAIFMT_CBS_CFS:
+			val |= I2S_SLAVE;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	AUDIO_WRITE(nuc980_audio->mmio + ACTL_I2SCON, val);
+
+	return 0;
+}
+
+static int nuc980_i2s_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id, unsigned int freq, int dir)
+{
+	unsigned int val;
+	struct nuc980_audio *nuc980_audio = nuc980_i2s_data;
+	struct clk *clkmux, *clkapll, *clkaudio;
+	int ret;
+	unsigned int mclkdiv, bclkdiv, mclk;
+
+	clkmux = clk_get(NULL, "audio_eclk_mux");
+		if (IS_ERR(clkmux)) {
+			printk(KERN_ERR "nuc980-audio:failed to get audio clock source\n");
+			ret = PTR_ERR(clkmux);
+			return ret;
+		}
+		clkapll = clk_get(NULL, "apll");
+		if (IS_ERR(clkapll)) {
+			printk(KERN_ERR "nuc980-audio:failed to get audio clock source\n");
+			ret = PTR_ERR(clkapll);
+			return ret;
+		}
+
+		clkaudio = clk_get(NULL, "audio_eclk");
+		if (IS_ERR(clkaudio)) {
+			printk(KERN_ERR "nuc980-audio:failed to get audio clock source\n");
+			ret = PTR_ERR(clkaudio);
+			return ret;
+		}
+
+	if (clk_id == NUC980_AUDIO_SAMPLECLK) {
+		val = AUDIO_READ(nuc980_audio->mmio + ACTL_I2SCON);
+
+		mclk = (freq*256);      // 256fs
+		mclkdiv = clk_get_rate(clkaudio) / mclk;
+		val &= ~0x000F0000;
+		val |= (mclkdiv-1) << 16;
+
+		bclkdiv = mclk / (freq * cpu_dai->sample_bits * cpu_dai->channels);
+		bclkdiv = bclkdiv/2 - 1;
+		val &= ~0xf0;
+		val |= (bclkdiv << 5);
+
+		AUDIO_WRITE(nuc980_audio->mmio + ACTL_I2SCON, val);
+	}
+
+	if (clk_id == NUC980_AUDIO_CLKDIV) {
+		//use APLL to generate 12.288MHz ,16.934MHz or 11.285Mhz for I2S
+		//input source clock is XIN=12Mhz
+
+		clk_set_parent(clkmux, clkapll);
+
+		if ((freq % 8000 == 0) && (freq != 32000)) {
+			//12.288MHz ==> APLL=98.4MHz / 8 = 12.3MHz
+			clk_set_rate(clkapll, 98400000);
+			clk_set_rate(clkaudio, 12300000);
+		} else if(freq == 44100) {
+			//16.934MHz ==> APLL=169.5MHz / 15 = 11.30MHz
+			clk_set_rate(clkapll, 169500000);
+			clk_set_rate(clkaudio, 11300000);
+		} else {
+			//16.934MHz ==> APLL=169.5MHz / 10 = 16.95MHz
+			clk_set_rate(clkapll, 169500000);
+			clk_set_rate(clkaudio, 16950000);
+		}
+	}
+
+	return 0;
+}
+
+static int nuc980_i2s_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *dai)
+{
+	struct nuc980_audio *nuc980_audio = nuc980_i2s_data;
+	int ret = 0;
+	unsigned long val, con;
+
+	con = AUDIO_READ(nuc980_audio->mmio + ACTL_CON);
+
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+			val = AUDIO_READ(nuc980_audio->mmio + ACTL_RESET);
+			con |= I2S_EN;
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				con |= P_DMA_IRQ_EN;
+				AUDIO_WRITE(nuc980_audio->mmio + ACTL_PSR, P_DMA_RIA_IRQ);
+
+				val |= AUDIO_PLAY;
+			} else {
+				con |= R_DMA_IRQ_EN;
+				AUDIO_WRITE(nuc980_audio->mmio + ACTL_RSR, R_DMA_RIA_IRQ);
+
+				val |= AUDIO_RECORD;
+			}
+			AUDIO_WRITE(nuc980_audio->mmio + ACTL_RESET, val);
+			AUDIO_WRITE(nuc980_audio->mmio + ACTL_CON, con);
+
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+			val = AUDIO_READ(nuc980_audio->mmio + ACTL_RESET);
+			con &= ~I2S_EN;
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				con &= ~P_DMA_IRQ_EN;
+				AUDIO_WRITE(nuc980_audio->mmio + ACTL_PSR, RESET_PRSR);
+				val &= ~AUDIO_PLAY;
+			} else {
+				con &= ~R_DMA_IRQ_EN;
+				AUDIO_WRITE(nuc980_audio->mmio + ACTL_RSR, RESET_PRSR);
+				val &= ~AUDIO_RECORD;
+			}
+
+			AUDIO_WRITE(nuc980_audio->mmio + ACTL_RESET, val);
+			AUDIO_WRITE(nuc980_audio->mmio + ACTL_CON, con);
+
+			break;
+		default:
+			ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int nuc980_i2s_probe(struct snd_soc_dai *dai)
+{
+	struct nuc980_audio *nuc980_audio = nuc980_i2s_data;
+	unsigned long val;
+
+	mutex_lock(&i2s_mutex);
+
+	clk_prepare(clk_get(NULL, "audio_hclk"));
+	clk_enable(clk_get(NULL, "audio_hclk"));
+
+	/* enable unit clock */
+	clk_prepare(nuc980_audio->clk);
+	clk_enable(nuc980_audio->clk);
+
+	/* Select I2S pins */
+	val = AUDIO_READ(nuc980_audio->mmio + ACTL_CON);
+	val = (val & ~0x300) | BITS_SELECT_16;          //set default data bit to 16-bit
+	AUDIO_WRITE(nuc980_audio->mmio + ACTL_CON, val);
+
+	mutex_unlock(&i2s_mutex);
+
+	return 0;
+}
+
+static int nuc980_i2s_remove(struct snd_soc_dai *dai)
+{
+	struct nuc980_audio *nuc980_audio = nuc980_i2s_data;
+	clk_disable(nuc980_audio->clk);
+
+	return 0;
+}
+
+static struct snd_soc_dai_ops nuc980_i2s_dai_ops = {
+	.trigger    = nuc980_i2s_trigger,
+	.hw_params  = nuc980_i2s_hw_params,
+	.set_fmt    = nuc980_i2s_set_fmt,
+	.set_sysclk = nuc980_i2s_set_sysclk,
+};
+
+struct snd_soc_dai_driver nuc980_i2s_dai = {
+	.probe          = nuc980_i2s_probe,
+	.remove         = nuc980_i2s_remove,
+	.playback = {
+		.rates      = SNDRV_PCM_RATE_8000_48000,
+		.formats    = SNDRV_PCM_FMTBIT_S16_LE,
+		.channels_min   = 1,
+		.channels_max   = 2,
+	},
+	.capture = {
+		.rates      = SNDRV_PCM_RATE_8000_48000,
+		.formats    = SNDRV_PCM_FMTBIT_S16_LE,
+		.channels_min   = 1,
+		.channels_max   = 2,
+	},
+	.ops = &nuc980_i2s_dai_ops,
+};
+
+static const struct snd_soc_component_driver nuc980_i2s_component = {
+	.name       = "nuc980-i2s",
+};
+
+static int nuc980_i2s_drvprobe(struct platform_device *pdev)
+{
+	struct nuc980_audio *nuc980_audio;
+	struct pinctrl *pinctrl;
+	int ret;
+
+	if (nuc980_i2s_data)
+		return -EBUSY;
+
+	nuc980_audio = kzalloc(sizeof(struct nuc980_audio), GFP_KERNEL);
+	if (!nuc980_audio)
+		return -ENOMEM;
+
+	spin_lock_init(&nuc980_audio->lock);
+	spin_lock_init(&nuc980_audio->irqlock);
+
+	nuc980_audio->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!nuc980_audio->res) {
+		ret = -ENODEV;
+		goto out0;
+	}
+
+	if (!request_mem_region(nuc980_audio->res->start, resource_size(nuc980_audio->res), pdev->name)) {
+		ret = -EBUSY;
+		goto out0;
+	}
+
+	nuc980_audio->mmio = ioremap(nuc980_audio->res->start, resource_size(nuc980_audio->res));
+	if (!nuc980_audio->mmio) {
+		ret = -ENOMEM;
+		goto out1;
+	}
+
+	nuc980_audio->clk = clk_get(NULL, "audio_eclk");
+	if (IS_ERR(nuc980_audio->clk)) {
+		ret = PTR_ERR(nuc980_audio->clk);
+		goto out2;
+	}
+
+	nuc980_audio->irq_num = platform_get_irq(pdev, 0);
+	if (!nuc980_audio->irq_num) {
+		ret = -EBUSY;
+		goto out3;
+	}
+
+	ret = nuc980_dma_create(nuc980_audio);
+	if (ret != 0)
+		return ret;
+
+	nuc980_i2s_data = nuc980_audio;
+
+	ret = snd_soc_register_component(&pdev->dev, &nuc980_i2s_component, &nuc980_i2s_dai, 1);
+	if (ret)
+		goto out3;
+
+#if defined(CONFIG_OF)
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl)) {
+		return PTR_ERR(pinctrl);
+	}
+#else
+
+	/* initial I2S pin */
+#if defined (CONFIG_NUC980_I2S_PA)
+
+	pinctrl = devm_pinctrl_get_select(&pdev->dev, "i2s-PA");
+
+#elif defined (CONFIG_NUC980_I2S_PB)
+
+	pinctrl = devm_pinctrl_get_select(&pdev->dev, "i2s-PB");
+
+#endif
+
+	if (IS_ERR(pinctrl))
+	{
+		dev_err(&pdev->dev, "unable to reserve pin\n");
+		ret = PTR_ERR(pinctrl);
+	}
+#endif
+
+	return 0;
+
+out3:
+	clk_put(nuc980_audio->clk);
+out2:
+	iounmap(nuc980_audio->mmio);
+out1:
+	release_mem_region(nuc980_audio->res->start, resource_size(nuc980_audio->res));
+out0:
+	kfree(nuc980_audio);
+
+	return ret;
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id nuc980_audio_i2s_of_match[] = {
+	{   .compatible = "nuvoton,nuc980-audio-i2s"    },
+	{   },
+};
+MODULE_DEVICE_TABLE(of, nuc980_audio_i2s_of_match);
+#endif
+
+static int nuc980_i2s_drvremove(struct platform_device *pdev)
+{
+	nuc980_dma_destroy(nuc980_i2s_data);
+	snd_soc_unregister_component(&pdev->dev);
+
+	clk_put(nuc980_i2s_data->clk);
+	iounmap(nuc980_i2s_data->mmio);
+	release_mem_region(nuc980_i2s_data->res->start, resource_size(nuc980_i2s_data->res));
+
+	kfree(nuc980_i2s_data);
+	nuc980_i2s_data = NULL;
+
+	return 0;
+}
+
+static struct platform_driver nuc980_i2s_driver = {
+	.driver = {
+		.name   = "nuc980-audio-i2s",
+		.owner  = THIS_MODULE,
+#if defined(CONFIG_OF)
+		.of_match_table = of_match_ptr(nuc980_audio_i2s_of_match),
+#endif
+	},
+	.probe      = nuc980_i2s_drvprobe,
+	.remove     = nuc980_i2s_drvremove,
+};
+
+module_platform_driver(nuc980_i2s_driver);
+
+MODULE_DESCRIPTION("NUC980 IIS SoC driver!");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:nuc980-i2s");
diff -uprN linux-4.4.194/sound/soc/nuc980/nuc980-pcm.c NUC980-linux-4.4.194/sound/soc/nuc980/nuc980-pcm.c
--- linux-4.4.194/sound/soc/nuc980/nuc980-pcm.c	1969-12-31 16:00:00.000000000 -0800
+++ NUC980-linux-4.4.194/sound/soc/nuc980/nuc980-pcm.c	2019-12-29 19:12:21.000000000 -0800
@@ -0,0 +1,354 @@
+/*
+ * Copyright (c) 2018 Nuvoton technology corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/of.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <mach/hardware.h>
+
+#include "nuc980-audio.h"
+
+static const struct snd_pcm_hardware nuc980_pcm_hardware = {
+	.info           = SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_PAUSE |
+				SNDRV_PCM_INFO_RESUME,
+	.formats        = SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_S24_LE,
+	.rates          = SNDRV_PCM_RATE_32000 |
+				SNDRV_PCM_RATE_44100 |
+				SNDRV_PCM_RATE_48000,
+	.channels_min       = 1,
+	.channels_max       = 2,
+	.buffer_bytes_max   = 4*1024,
+	.period_bytes_min   = 1*1024,
+	.period_bytes_max   = 4*1024,
+	.periods_min        = 1,
+	.periods_max        = 1024,
+};
+
+static int nuc980_dma_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct nuc980_audio *nuc980_audio = runtime->private_data;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&nuc980_audio->irqlock, flags);
+
+	if(runtime->dma_addr == 0) {
+		ret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+		if (ret < 0)
+			return ret;
+		nuc980_audio->substream[substream->stream] = substream;
+	}
+
+	nuc980_audio->dma_addr[substream->stream] = runtime->dma_addr | 0x80000000;
+	nuc980_audio->buffersize[substream->stream] = params_buffer_bytes(params);
+
+	spin_unlock_irqrestore(&nuc980_audio->irqlock, flags);
+
+	return ret;
+}
+
+static void nuc980_update_dma_register(struct snd_pcm_substream *substream,
+				dma_addr_t dma_addr, size_t count)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct nuc980_audio *nuc980_audio = runtime->private_data;
+	void __iomem *mmio_addr, *mmio_len;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		mmio_addr = nuc980_audio->mmio + ACTL_PDESB;
+		mmio_len = nuc980_audio->mmio + ACTL_PDES_LENGTH;
+	} else {
+		mmio_addr = nuc980_audio->mmio + ACTL_RDESB;
+		mmio_len = nuc980_audio->mmio + ACTL_RDES_LENGTH;
+	}
+
+	AUDIO_WRITE(mmio_addr, dma_addr);
+	AUDIO_WRITE(mmio_len, count);
+}
+
+static irqreturn_t nuc980_dma_interrupt(int irq, void *dev_id)
+{
+	struct nuc980_audio *nuc980_audio = dev_id;
+	unsigned long val;
+	unsigned long flags;
+	int stream;
+
+	spin_lock_irqsave(&nuc980_audio->irqlock, flags);
+
+	val = AUDIO_READ(nuc980_audio->mmio + ACTL_CON);
+
+	if (val & R_DMA_IRQ) {
+		stream = SNDRV_PCM_STREAM_CAPTURE;
+		AUDIO_WRITE(nuc980_audio->mmio + ACTL_CON, val | R_DMA_IRQ);
+
+		val = AUDIO_READ(nuc980_audio->mmio + ACTL_RSR);
+
+		if (val & R_DMA_RIA_IRQ) {
+			val = R_DMA_RIA_IRQ;
+			AUDIO_WRITE(nuc980_audio->mmio + ACTL_RSR, val);
+		}
+
+	} else if (val & P_DMA_IRQ) {
+		stream = SNDRV_PCM_STREAM_PLAYBACK;
+		AUDIO_WRITE(nuc980_audio->mmio + ACTL_CON, val | P_DMA_IRQ);
+
+		val = AUDIO_READ(nuc980_audio->mmio + ACTL_PSR);
+
+		if (val & P_DMA_RIA_IRQ) {
+			val = P_DMA_RIA_IRQ;
+			AUDIO_WRITE(nuc980_audio->mmio + ACTL_PSR, val);
+		}
+
+	} else {
+		dev_err(nuc980_audio->dev, "Wrong DMA interrupt status!\n");
+		spin_unlock_irqrestore(&nuc980_audio->irqlock, flags);
+		return IRQ_HANDLED;
+	}
+
+	spin_unlock_irqrestore(&nuc980_audio->irqlock, flags);
+
+	snd_pcm_period_elapsed(nuc980_audio->substream[stream]);
+
+	return IRQ_HANDLED;
+}
+
+static int nuc980_dma_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct nuc980_audio *nuc980_audio = runtime->private_data;
+
+	snd_pcm_lib_free_pages(substream);
+	nuc980_audio->substream[substream->stream] = NULL;
+	return 0;
+}
+
+static int nuc980_dma_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct nuc980_audio *nuc980_audio = runtime->private_data;
+	unsigned long flags, val;
+	int ret = 0;
+
+	spin_lock_irqsave(&nuc980_audio->irqlock, flags);
+
+	nuc980_update_dma_register(substream,
+				nuc980_audio->dma_addr[substream->stream],
+				nuc980_audio->buffersize[substream->stream]);
+
+	val = AUDIO_READ(nuc980_audio->mmio + ACTL_RESET);
+
+	switch (runtime->channels) {
+	case 1:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			val &= ~(PLAY_LEFT_CHNNEL | PLAY_RIGHT_CHNNEL);
+			val |= PLAY_RIGHT_CHNNEL;
+		} else {
+			val &= ~(RECORD_LEFT_CHNNEL | RECORD_RIGHT_CHNNEL);
+			val |= RECORD_LEFT_CHNNEL;
+		}
+		AUDIO_WRITE(nuc980_audio->mmio + ACTL_RESET, val);
+		break;
+	case 2:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			val |= (PLAY_LEFT_CHNNEL | PLAY_RIGHT_CHNNEL);
+		else
+			val |= (RECORD_LEFT_CHNNEL | RECORD_RIGHT_CHNNEL);
+		AUDIO_WRITE(nuc980_audio->mmio + ACTL_RESET, val);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	/* set DMA IRQ to half */
+	val = AUDIO_READ(nuc980_audio->mmio + ACTL_CON);
+	val &= ~0xf000;
+	val |= (R_DMA_IRQ_SEL_HALF | P_DMA_IRQ_SEL_HALF);
+	AUDIO_WRITE(nuc980_audio->mmio + ACTL_CON, val);
+
+	spin_unlock_irqrestore(&nuc980_audio->irqlock, flags);
+	return ret;
+}
+
+static int nuc980_dma_getposition(struct snd_pcm_substream *substream,
+					dma_addr_t *src, dma_addr_t *dst)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct nuc980_audio *nuc980_audio = runtime->private_data;
+
+	if (src != NULL)
+		*src = AUDIO_READ(nuc980_audio->mmio + ACTL_PDESC);
+
+	if (dst != NULL)
+		*dst = AUDIO_READ(nuc980_audio->mmio + ACTL_RDESC);
+
+	return 0;
+}
+
+static snd_pcm_uframes_t nuc980_dma_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	dma_addr_t src, dst;
+	unsigned long res;
+	struct nuc980_audio *nuc980_audio = runtime->private_data;
+	snd_pcm_uframes_t frames;
+
+	spin_lock(&nuc980_audio->lock);
+
+	nuc980_dma_getposition(substream, &src, &dst);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		res = dst - runtime->dma_addr;
+	else
+		res = src - runtime->dma_addr;
+
+	 frames = bytes_to_frames(substream->runtime, res);
+
+	 spin_unlock(&nuc980_audio->lock);
+
+	 return frames;
+}
+
+static int nuc980_dma_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct nuc980_audio *nuc980_audio;
+
+	snd_soc_set_runtime_hwparams(substream, &nuc980_pcm_hardware);
+	nuc980_audio = nuc980_i2s_data;
+	runtime->private_data = nuc980_audio;
+
+	return 0;
+}
+
+static int nuc980_dma_close(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+int nuc980_dma_create(struct nuc980_audio *nuc980_audio)
+{
+	int ret = request_irq(nuc980_audio->irq_num, nuc980_dma_interrupt, 0, "nuc980-dma", nuc980_audio);
+
+	if(ret)
+		return -EBUSY;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(nuc980_dma_create);
+
+int nuc980_dma_destroy(struct nuc980_audio *nuc980_audio)
+{
+	 free_irq(nuc980_audio->irq_num, nuc980_audio);
+
+	 return 0;
+}
+EXPORT_SYMBOL_GPL(nuc980_dma_destroy);
+
+static int nuc980_dma_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+					runtime->dma_area,
+					runtime->dma_addr,
+					runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops nuc980_dma_ops = {
+	.open       = nuc980_dma_open,
+	.close      = nuc980_dma_close,
+	.ioctl      = snd_pcm_lib_ioctl,
+	.hw_params  = nuc980_dma_hw_params,
+	.hw_free    = nuc980_dma_hw_free,
+	.prepare    = nuc980_dma_prepare,
+	.pointer    = nuc980_dma_pointer,
+	.mmap       = nuc980_dma_mmap,
+};
+
+static void nuc980_dma_free_dma_buffers(struct snd_pcm *pcm)
+{
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static u64 nuc980_pcm_dmamask = DMA_BIT_MASK(32);
+static int nuc980_dma_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm *pcm = rtd->pcm;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &nuc980_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+		card->dev, 4 * 1024, (4 * 1024) - 1);
+
+	return 0;
+}
+
+static struct snd_soc_platform_driver nuc980_soc_platform = {
+	.ops        = &nuc980_dma_ops,
+	.pcm_new    = nuc980_dma_new,
+	.pcm_free   = nuc980_dma_free_dma_buffers,
+};
+
+static int nuc980_soc_platform_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &nuc980_soc_platform);
+}
+
+static int nuc980_soc_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id nuc980_audio_pcm_of_match[] = {
+	{   .compatible = "nuvoton,nuc980-audio-pcm"    },
+	{   },
+};
+MODULE_DEVICE_TABLE(of, nuc980_audio_pcm_of_match);
+#endif
+
+static struct platform_driver nuc980_pcm_driver = {
+	.driver = {
+			.name = "nuc980-audio-pcm",
+			.owner = THIS_MODULE,
+#if defined(CONFIG_OF)
+			.of_match_table = of_match_ptr(nuc980_audio_pcm_of_match),
+#endif
+	},
+
+	.probe = nuc980_soc_platform_probe,
+	.remove = nuc980_soc_platform_remove,
+};
+
+module_platform_driver(nuc980_pcm_driver);
+
+MODULE_DESCRIPTION("nuc980 Audio DMA module");
+MODULE_LICENSE("GPL");
