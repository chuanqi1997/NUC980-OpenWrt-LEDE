diff -uprN linux-4.4.194/drivers/spi/Kconfig NUC980-linux-4.4.y-master/drivers/spi/Kconfig
--- linux-4.4.194/drivers/spi/Kconfig	2021-08-05 23:48:46.567220000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/Kconfig	2021-06-20 19:14:48.000000000 -0700
@@ -254,15 +254,6 @@ config SPI_IMG_SPFI
 	  This enables support for the SPFI master controller found on
 	  IMG SoCs.
 
-config SPI_GPIO_OLD
-	tristate "Old GPIO API based bitbanging SPI controller (DEPRECATED)"
-	depends on SPI_MASTER && GPIOLIB
-	select SPI_BITBANG
-	help
-	  This code is deprecated. Please use the new mainline SPI-GPIO driver.
-
-	  If unsure, say N.
-
 config SPI_IMX
 	tristate "Freescale i.MX SPI controllers"
 	depends on ARCH_MXC || COMPILE_TEST
diff -uprN linux-4.4.194/drivers/spi/Makefile NUC980-linux-4.4.y-master/drivers/spi/Makefile
--- linux-4.4.194/drivers/spi/Makefile	2021-08-05 23:48:46.567220000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/Makefile	2021-06-20 19:14:48.000000000 -0700
@@ -42,7 +42,6 @@ obj-$(CONFIG_SPI_FSL_LIB)		+= spi-fsl-li
 obj-$(CONFIG_SPI_FSL_ESPI)		+= spi-fsl-espi.o
 obj-$(CONFIG_SPI_FSL_SPI)		+= spi-fsl-spi.o
 obj-$(CONFIG_SPI_GPIO)			+= spi-gpio.o
-obj-$(CONFIG_SPI_GPIO_OLD)		+= spi_gpio_old.o
 obj-$(CONFIG_SPI_IMG_SPFI)		+= spi-img-spfi.o
 obj-$(CONFIG_SPI_IMX)			+= spi-imx.o
 obj-$(CONFIG_SPI_LM70_LLP)		+= spi-lm70llp.o
diff -uprN linux-4.4.194/drivers/spi/spi-atmel.c NUC980-linux-4.4.y-master/drivers/spi/spi-atmel.c
--- linux-4.4.194/drivers/spi/spi-atmel.c	2019-09-20 22:12:54.000000000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/spi-atmel.c	2021-06-20 19:14:48.000000000 -0700
@@ -1209,10 +1209,8 @@ static int atmel_spi_setup(struct spi_de
 	as = spi_master_get_devdata(spi->master);
 
 	/* see notes above re chipselect */
-	if (!atmel_spi_is_v2(as)
-			&& spi->chip_select == 0
-			&& (spi->mode & SPI_CS_HIGH)) {
-		dev_dbg(&spi->dev, "setup: can't be active-high\n");
+	if (!as->use_cs_gpios && (spi->mode & SPI_CS_HIGH)) {
+		dev_warn(&spi->dev, "setup: non GPIO CS can't be active-high\n");
 		return -EINVAL;
 	}
 
diff -uprN linux-4.4.194/drivers/spi/spi-bcm53xx.c NUC980-linux-4.4.y-master/drivers/spi/spi-bcm53xx.c
--- linux-4.4.194/drivers/spi/spi-bcm53xx.c	2021-08-05 23:48:46.187220000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/spi-bcm53xx.c	2021-06-20 19:14:48.000000000 -0700
@@ -10,7 +10,6 @@
 #include "spi-bcm53xx.h"
 
 #define BCM53XXSPI_MAX_SPI_BAUD	13500000	/* 216 MHz? */
-#define BCM53XXSPI_FLASH_WINDOW	SZ_32M
 
 /* The longest observed required wait was 19 ms */
 #define BCM53XXSPI_SPE_TIMEOUT_MS	80
@@ -18,10 +17,8 @@
 struct bcm53xxspi {
 	struct bcma_device *core;
 	struct spi_master *master;
-	void __iomem *mmio_base;
 
 	size_t read_offset;
-	bool bspi;				/* Boot SPI mode with memory mapping */
 };
 
 static inline u32 bcm53xxspi_read(struct bcm53xxspi *b53spi, u16 offset)
@@ -35,50 +32,6 @@ static inline void bcm53xxspi_write(stru
 	bcma_write32(b53spi->core, offset, value);
 }
 
-static void bcm53xxspi_disable_bspi(struct bcm53xxspi *b53spi)
-{
-	struct device *dev = &b53spi->core->dev;
-	unsigned long deadline;
-	u32 tmp;
-
-	if (!b53spi->bspi)
-		return;
-
-	tmp = bcm53xxspi_read(b53spi, B53SPI_BSPI_MAST_N_BOOT_CTRL);
-	if (tmp & 0x1)
-		return;
-
-	deadline = jiffies + usecs_to_jiffies(200);
-	do {
-		tmp = bcm53xxspi_read(b53spi, B53SPI_BSPI_BUSY_STATUS);
-		if (!(tmp & 0x1)) {
-			bcm53xxspi_write(b53spi, B53SPI_BSPI_MAST_N_BOOT_CTRL,
-					 0x1);
-			ndelay(200);
-			b53spi->bspi = false;
-			return;
-		}
-		udelay(1);
-	} while (!time_after_eq(jiffies, deadline));
-
-	dev_warn(dev, "Timeout disabling BSPI\n");
-}
-
-static void bcm53xxspi_enable_bspi(struct bcm53xxspi *b53spi)
-{
-	u32 tmp;
-
-	if (b53spi->bspi)
-		return;
-
-	tmp = bcm53xxspi_read(b53spi, B53SPI_BSPI_MAST_N_BOOT_CTRL);
-	if (!(tmp & 0x1))
-		return;
-
-	bcm53xxspi_write(b53spi, B53SPI_BSPI_MAST_N_BOOT_CTRL, 0x0);
-	b53spi->bspi = true;
-}
-
 static inline unsigned int bcm53xxspi_calc_timeout(size_t len)
 {
 	/* Do some magic calculation based on length and buad. Add 10% and 1. */
@@ -223,8 +176,6 @@ static int bcm53xxspi_transfer_one(struc
 	u8 *buf;
 	size_t left;
 
-	bcm53xxspi_disable_bspi(b53spi);
-
 	if (t->tx_buf) {
 		buf = (u8 *)t->tx_buf;
 		left = t->len;
@@ -255,22 +206,6 @@ static int bcm53xxspi_transfer_one(struc
 	return 0;
 }
 
-static int bcm53xxspi_flash_read(struct spi_device *spi,
-				 struct spi_flash_read_message *msg)
-{
-	struct bcm53xxspi *b53spi = spi_master_get_devdata(spi->master);
-	int ret = 0;
-
-	if (msg->from + msg->len > BCM53XXSPI_FLASH_WINDOW)
-		return -EINVAL;
-
-	bcm53xxspi_enable_bspi(b53spi);
-	memcpy_fromio(msg->buf, b53spi->mmio_base + msg->from, msg->len);
-	msg->retlen = msg->len;
-
-	return ret;
-}
-
 /**************************************************
  * BCMA
  **************************************************/
@@ -287,7 +222,6 @@ MODULE_DEVICE_TABLE(bcma, bcm53xxspi_bcm
 
 static int bcm53xxspi_bcma_probe(struct bcma_device *core)
 {
-	struct device *dev = &core->dev;
 	struct bcm53xxspi *b53spi;
 	struct spi_master *master;
 	int err;
@@ -297,7 +231,7 @@ static int bcm53xxspi_bcma_probe(struct
 		return -ENOTSUPP;
 	}
 
-	master = spi_alloc_master(dev, sizeof(*b53spi));
+	master = spi_alloc_master(&core->dev, sizeof(*b53spi));
 	if (!master)
 		return -ENOMEM;
 
@@ -305,19 +239,11 @@ static int bcm53xxspi_bcma_probe(struct
 	b53spi->master = master;
 	b53spi->core = core;
 
-	if (core->addr_s[0])
-		b53spi->mmio_base = devm_ioremap(dev, core->addr_s[0],
-						 BCM53XXSPI_FLASH_WINDOW);
-	b53spi->bspi = true;
-	bcm53xxspi_disable_bspi(b53spi);
-
 	master->transfer_one = bcm53xxspi_transfer_one;
-	if (b53spi->mmio_base)
-		master->spi_flash_read = bcm53xxspi_flash_read;
 
 	bcma_set_drvdata(core, b53spi);
 
-	err = devm_spi_register_master(dev, master);
+	err = devm_spi_register_master(&core->dev, master);
 	if (err) {
 		spi_master_put(master);
 		bcma_set_drvdata(core, NULL);
diff -uprN linux-4.4.194/drivers/spi/spi.c NUC980-linux-4.4.y-master/drivers/spi/spi.c
--- linux-4.4.194/drivers/spi/spi.c	2021-08-05 23:48:46.223220000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/spi.c	2021-06-20 19:14:48.000000000 -0700
@@ -674,7 +674,7 @@ static void spi_set_cs(struct spi_device
 		enable = !enable;
 
 	if (gpio_is_valid(spi->cs_gpio))
-		gpio_set_value_cansleep(spi->cs_gpio, !enable);
+		gpio_set_value(spi->cs_gpio, !enable);
 	else if (spi->master->set_cs)
 		spi->master->set_cs(spi, !enable);
 }
@@ -1143,7 +1143,6 @@ static void __spi_pump_messages(struct s
 		}
 	}
 
-	mutex_lock(&master->bus_lock_mutex);
 	trace_spi_message_start(master->cur_msg);
 
 	if (master->prepare_message) {
@@ -1153,7 +1152,6 @@ static void __spi_pump_messages(struct s
 				"failed to prepare message: %d\n", ret);
 			master->cur_msg->status = ret;
 			spi_finalize_current_message(master);
-			mutex_unlock(&master->bus_lock_mutex);
 			return;
 		}
 		master->cur_msg_prepared = true;
@@ -1163,7 +1161,6 @@ static void __spi_pump_messages(struct s
 	if (ret) {
 		master->cur_msg->status = ret;
 		spi_finalize_current_message(master);
-		mutex_unlock(&master->bus_lock_mutex);
 		return;
 	}
 
@@ -1171,10 +1168,8 @@ static void __spi_pump_messages(struct s
 	if (ret) {
 		dev_err(&master->dev,
 			"failed to transfer one message from queue\n");
-		mutex_unlock(&master->bus_lock_mutex);
 		return;
 	}
-	mutex_unlock(&master->bus_lock_mutex);
 }
 
 /**
@@ -2342,46 +2337,6 @@ int spi_async_locked(struct spi_device *
 EXPORT_SYMBOL_GPL(spi_async_locked);
 
 
-int spi_flash_read(struct spi_device *spi,
-		   struct spi_flash_read_message *msg)
-
-{
-	struct spi_master *master = spi->master;
-	int ret;
-
-	if ((msg->opcode_nbits == SPI_NBITS_DUAL ||
-	     msg->addr_nbits == SPI_NBITS_DUAL) &&
-	    !(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
-		return -EINVAL;
-	if ((msg->opcode_nbits == SPI_NBITS_QUAD ||
-	     msg->addr_nbits == SPI_NBITS_QUAD) &&
-	    !(spi->mode & SPI_TX_QUAD))
-		return -EINVAL;
-	if (msg->data_nbits == SPI_NBITS_DUAL &&
-	    !(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
-		return -EINVAL;
-	if (msg->data_nbits == SPI_NBITS_QUAD &&
-	    !(spi->mode &  SPI_RX_QUAD))
-		return -EINVAL;
-
-	if (master->auto_runtime_pm) {
-		ret = pm_runtime_get_sync(master->dev.parent);
-		if (ret < 0) {
-			dev_err(&master->dev, "Failed to power device: %d\n",
-				ret);
-			return ret;
-		}
-	}
-	mutex_lock(&master->bus_lock_mutex);
-	ret = master->spi_flash_read(spi, msg);
-	mutex_unlock(&master->bus_lock_mutex);
-	if (master->auto_runtime_pm)
-		pm_runtime_put(master->dev.parent);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(spi_flash_read);
-
 /*-------------------------------------------------------------------------*/
 
 /* Utility methods for SPI master protocol drivers, layered on
diff -uprN linux-4.4.194/drivers/spi/spidev.c NUC980-linux-4.4.y-master/drivers/spi/spidev.c
--- linux-4.4.194/drivers/spi/spidev.c	2021-08-05 23:48:46.223220000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/spidev.c	2021-06-20 19:14:48.000000000 -0700
@@ -695,7 +695,6 @@ static struct class *spidev_class;
 static const struct of_device_id spidev_dt_ids[] = {
 	{ .compatible = "rohm,dh2228fv" },
 	{ .compatible = "lineartechnology,ltc2488" },
-	{ .compatible = "siliconlabs,si3210" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
@@ -714,11 +713,9 @@ static int spidev_probe(struct spi_devic
 	 * compatible string, it is a Linux implementation thing
 	 * rather than a description of the hardware.
 	 */
-	if (spi->dev.of_node && !of_match_device(spidev_dt_ids, &spi->dev)) {
-		dev_err(&spi->dev, "buggy DT: spidev listed directly in DT\n");
-		WARN_ON(spi->dev.of_node &&
-			!of_match_device(spidev_dt_ids, &spi->dev));
-	}
+	WARN(spi->dev.of_node &&
+	     of_device_is_compatible(spi->dev.of_node, "spidev"),
+	     "%pOF: buggy DT: spidev listed directly in DT\n", spi->dev.of_node);
 
 	/* Allocate driver data */
 	spidev = kzalloc(sizeof(*spidev), GFP_KERNEL);
diff -uprN linux-4.4.194/drivers/spi/spi-gpio.c NUC980-linux-4.4.y-master/drivers/spi/spi-gpio.c
--- linux-4.4.194/drivers/spi/spi-gpio.c	2021-08-05 23:48:46.403220000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/spi-gpio.c	2021-06-20 19:14:48.000000000 -0700
@@ -17,7 +17,6 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/gpio.h>
-#include <linux/delay.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/of_gpio.h>
@@ -70,7 +69,6 @@ struct spi_gpio {
  *		#define	SPI_MOSI_GPIO	120
  *		#define	SPI_SCK_GPIO	121
  *		#define	SPI_N_CHIPSEL	4
- *		#undef NEED_SPIDELAY
  *		#include "spi-gpio.c"
  */
 
@@ -78,7 +76,6 @@ struct spi_gpio {
 #define DRIVER_NAME	"spi_gpio"
 
 #define GENERIC_BITBANG	/* vs tight inlines */
-#define NEED_SPIDELAY	1
 
 /* all functions referencing these symbols must define pdata */
 #define SPI_MISO_GPIO	((pdata)->miso)
@@ -129,20 +126,12 @@ static inline int getmiso(const struct s
 #undef pdata
 
 /*
- * NOTE:  to clock "as fast as we can", set spi_device.max_speed_hz
- * and spi_transfer.speed_hz to 0.
- * Otherwise this is a function of the requested device clock.
- * Software overhead means we usually have trouble
- * reaching even one Mbit/sec (except when we can inline bitops). So on small
- * embedded devices with fast SPI slaves you usually don't need a delay.
+ * NOTE:  this clocks "as fast as we can".  It "should" be a function of the
+ * requested device clock.  Software overhead means we usually have trouble
+ * reaching even one Mbit/sec (except when we can inline bitops), so for now
+ * we'll just assume we never need additional per-bit slowdowns.
  */
-static inline void spidelay(unsigned nsecs)
-{
-#ifdef NEED_SPIDELAY
-	if (unlikely(nsecs))
-		ndelay(nsecs);
-#endif /* NEED_SPIDELAY */
-}
+#define spidelay(nsecs)	do {} while (0)
 
 #include "spi-bitbang-txrx.h"
 
diff -uprN linux-4.4.194/drivers/spi/spi_gpio_old.c NUC980-linux-4.4.y-master/drivers/spi/spi_gpio_old.c
--- linux-4.4.194/drivers/spi/spi_gpio_old.c	2021-08-05 23:48:46.403220000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/spi_gpio_old.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,251 +0,0 @@
-/*
- * Bitbanging SPI bus driver using GPIO API
- *
- * Copyright (c) 2008 Piotr Skamruk
- * Copyright (c) 2008 Michael Buesch
- *
- * based on spi_s3c2410_gpio.c
- *   Copyright (c) 2006 Ben Dooks
- *   Copyright (c) 2006 Simtec Electronics
- * and on i2c-gpio.c
- *   Copyright (C) 2007 Atmel Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/spinlock.h>
-#include <linux/workqueue.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/spi/spi.h>
-#include <linux/spi/spi_bitbang.h>
-#include <linux/spi/spi_gpio_old.h>
-#include <linux/gpio.h>
-#include <asm/atomic.h>
-
-
-struct spi_gpio {
-	struct spi_bitbang bitbang;
-	struct spi_gpio_platform_data *info;
-	struct platform_device *pdev;
-	struct spi_board_info bi;
-};
-
-
-static inline struct spi_gpio *spidev_to_sg(struct spi_device *dev)
-{
-	return dev->controller_data;
-}
-
-static inline void setsck(struct spi_device *dev, int val)
-{
-	struct spi_gpio *sp = spidev_to_sg(dev);
-	gpio_set_value(sp->info->pin_clk, val ? 1 : 0);
-}
-
-static inline void setmosi(struct spi_device *dev, int val)
-{
-	struct spi_gpio *sp = spidev_to_sg(dev);
-	gpio_set_value(sp->info->pin_mosi, val ? 1 : 0);
-}
-
-static inline u32 getmiso(struct spi_device *dev)
-{
-	struct spi_gpio *sp = spidev_to_sg(dev);
-	return gpio_get_value(sp->info->pin_miso) ? 1 : 0;
-}
-
-static inline void do_spidelay(struct spi_device *dev, unsigned nsecs)
-{
-	struct spi_gpio *sp = spidev_to_sg(dev);
-
-	if (!sp->info->no_spi_delay)
-		ndelay(nsecs);
-}
-
-#define spidelay(nsecs) do {					\
-	/* Steal the spi_device pointer from our caller.	\
-	 * The bitbang-API should probably get fixed here... */	\
-	do_spidelay(spi, nsecs);				\
-  } while (0)
-
-#define EXPAND_BITBANG_TXRX
-#include "spi-bitbang-txrx.h"
-
-static u32 spi_gpio_txrx_mode0(struct spi_device *spi,
-			       unsigned nsecs, u32 word, u8 bits)
-{
-	return bitbang_txrx_be_cpha0(spi, nsecs, 0, 0, word, bits);
-}
-
-static u32 spi_gpio_txrx_mode1(struct spi_device *spi,
-			       unsigned nsecs, u32 word, u8 bits)
-{
-	return bitbang_txrx_be_cpha1(spi, nsecs, 0, 0, word, bits);
-}
-
-static u32 spi_gpio_txrx_mode2(struct spi_device *spi,
-			       unsigned nsecs, u32 word, u8 bits)
-{
-	return bitbang_txrx_be_cpha0(spi, nsecs, 1, 0, word, bits);
-}
-
-static u32 spi_gpio_txrx_mode3(struct spi_device *spi,
-			       unsigned nsecs, u32 word, u8 bits)
-{
-	return bitbang_txrx_be_cpha1(spi, nsecs, 1, 0, word, bits);
-}
-
-static void spi_gpio_chipselect(struct spi_device *dev, int on)
-{
-	struct spi_gpio *sp = spidev_to_sg(dev);
-
-	if (sp->info->cs_activelow)
-		on = !on;
-	gpio_set_value(sp->info->pin_cs, on ? 1 : 0);
-}
-
-static int spi_gpio_probe(struct platform_device *pdev)
-{
-	struct spi_master *master;
-	struct spi_gpio_platform_data *pdata;
-	struct spi_gpio *sp;
-	struct spi_device *spidev;
-	int err;
-
-	pdata = pdev->dev.platform_data;
-	if (!pdata)
-		return -ENXIO;
-
-	err = -ENOMEM;
-	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_gpio));
-	if (!master)
-		goto err_alloc_master;
-
-	sp = spi_master_get_devdata(master);
-	platform_set_drvdata(pdev, sp);
-	sp->info = pdata;
-
-	err = gpio_request(pdata->pin_clk, "spi_clock");
-	if (err)
-		goto err_request_clk;
-	err = gpio_request(pdata->pin_mosi, "spi_mosi");
-	if (err)
-		goto err_request_mosi;
-	err = gpio_request(pdata->pin_miso, "spi_miso");
-	if (err)
-		goto err_request_miso;
-	err = gpio_request(pdata->pin_cs, "spi_cs");
-	if (err)
-		goto err_request_cs;
-
-	sp->bitbang.master = spi_master_get(master);
-	sp->bitbang.master->bus_num = -1;
-	sp->bitbang.master->num_chipselect = 1;
-	sp->bitbang.chipselect = spi_gpio_chipselect;
-	sp->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_txrx_mode0;
-	sp->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_txrx_mode1;
-	sp->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_txrx_mode2;
-	sp->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_txrx_mode3;
-
-	gpio_direction_output(pdata->pin_clk, 0);
-	gpio_direction_output(pdata->pin_mosi, 0);
-	gpio_direction_output(pdata->pin_cs,
-			      pdata->cs_activelow ? 1 : 0);
-	gpio_direction_input(pdata->pin_miso);
-
-	err = spi_bitbang_start(&sp->bitbang);
-	if (err)
-		goto err_no_bitbang;
-	err = pdata->boardinfo_setup(&sp->bi, master,
-				     pdata->boardinfo_setup_data);
-	if (err)
-		goto err_bi_setup;
-	sp->bi.controller_data = sp;
-	spidev = spi_new_device(master, &sp->bi);
-	if (!spidev)
-		goto err_new_dev;
-
-	return 0;
-
-err_new_dev:
-err_bi_setup:
-	spi_bitbang_stop(&sp->bitbang);
-err_no_bitbang:
-	spi_master_put(sp->bitbang.master);
-	gpio_free(pdata->pin_cs);
-err_request_cs:
-	gpio_free(pdata->pin_miso);
-err_request_miso:
-	gpio_free(pdata->pin_mosi);
-err_request_mosi:
-	gpio_free(pdata->pin_clk);
-err_request_clk:
-	kfree(master);
-
-err_alloc_master:
-	return err;
-}
-
-static int spi_gpio_remove(struct platform_device *pdev)
-{
-	struct spi_gpio *sp;
-	struct spi_gpio_platform_data *pdata;
-
-	pdata = pdev->dev.platform_data;
-	sp = platform_get_drvdata(pdev);
-
-	gpio_free(pdata->pin_clk);
-	gpio_free(pdata->pin_mosi);
-	gpio_free(pdata->pin_miso);
-	gpio_free(pdata->pin_cs);
-	spi_bitbang_stop(&sp->bitbang);
-	spi_master_put(sp->bitbang.master);
-
-	return 0;
-}
-
-static struct platform_driver spi_gpio_driver = {
-	.driver		= {
-		.name	= SPI_GPIO_PLATDEV_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= spi_gpio_probe,
-	.remove		= spi_gpio_remove,
-};
-
-int spi_gpio_next_id(void)
-{
-	static atomic_t counter = ATOMIC_INIT(-1);
-
-	return atomic_inc_return(&counter);
-}
-EXPORT_SYMBOL(spi_gpio_next_id);
-
-static int __init spi_gpio_init(void)
-{
-	int err;
-
-	err = platform_driver_register(&spi_gpio_driver);
-	if (err)
-		printk(KERN_ERR "spi-gpio: register failed: %d\n", err);
-
-	return err;
-}
-module_init(spi_gpio_init);
-
-static void __exit spi_gpio_exit(void)
-{
-	platform_driver_unregister(&spi_gpio_driver);
-}
-module_exit(spi_gpio_exit);
-
-MODULE_AUTHOR("Piot Skamruk <piotr.skamruk at gmail.com>");
-MODULE_AUTHOR("Michael Buesch");
-MODULE_DESCRIPTION("Platform independent GPIO bitbanging SPI driver");
-MODULE_LICENSE("GPL v2");
diff -uprN linux-4.4.194/drivers/spi/spi-nuc980-qspi0.c NUC980-linux-4.4.y-master/drivers/spi/spi-nuc980-qspi0.c
--- linux-4.4.194/drivers/spi/spi-nuc980-qspi0.c	2021-08-05 23:48:46.567220000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/spi-nuc980-qspi0.c	2021-06-20 19:14:48.000000000 -0700
@@ -235,7 +235,7 @@ static int nuc980_qspi0_txrx(struct spi_
 	struct nuc980_dma_config dma_crx,dma_ctx;
 	dma_cookie_t            cookie;
 #elif defined(CONFIG_SPI_NUC980_QSPI0_NO_PDMA)
-	unsigned int	i;
+	unsigned int	i,j;
 
 	hw->tx = t->tx_buf;
 	hw->rx = t->rx_buf;
@@ -426,10 +426,27 @@ static int nuc980_qspi0_txrx(struct spi_
 	}
 
 	if (hw->rx) {
-		for(i = 0; i < t->len; i++) {
-			__raw_writel(hw_tx(hw, i), hw->regs + REG_TX);
-			while (((__raw_readl(hw->regs + REG_STATUS) & 0x100) == 0x100)); //RXEMPTY
-			hw_rx(hw, __raw_readl(hw->regs + REG_RX), i);
+		j = 0;
+
+		for(i = 0; i < t->len; ) {
+			if(((__raw_readl(hw->regs + REG_STATUS) & 0x20000) == 0x00000)) //TX NOT FULL
+			{
+				__raw_writel(hw_tx(hw, i), hw->regs + REG_TX);
+				i++;
+			}
+			if(((__raw_readl(hw->regs + REG_STATUS) & 0x100) == 0x000)) //RX NOT EMPTY
+			{
+				hw_rx(hw, __raw_readl(hw->regs + REG_RX), j);
+				j++;
+			}
+		}
+		while(j < t->len)
+		{
+			if(((__raw_readl(hw->regs + REG_STATUS) & 0x100) == 0x000)) //RX NOT EMPTY
+			{
+				hw_rx(hw, __raw_readl(hw->regs + REG_RX), j);
+				j++;
+			}
 		}
 	} else {
 		for(i = 0; i < t->len; i++) {
diff -uprN linux-4.4.194/drivers/spi/spi-nuc980-spi0.c NUC980-linux-4.4.y-master/drivers/spi/spi-nuc980-spi0.c
--- linux-4.4.194/drivers/spi/spi-nuc980-spi0.c	2021-08-05 23:48:46.571220000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/spi-nuc980-spi0.c	2021-06-20 19:14:48.000000000 -0700
@@ -157,6 +157,8 @@ static inline void nuc980_slave_select(s
 			val |= SELECTSLAVE1;
 	}
 
+	while (__raw_readl(hw->regs + REG_STATUS) & 1); //wait busy
+
 	__raw_writel(val, hw->regs + REG_SSCTL);
 
 	spin_unlock_irqrestore(&hw->lock, flags);
@@ -231,7 +233,7 @@ static int nuc980_spi0_txrx(struct spi_d
 	struct nuc980_dma_config dma_crx,dma_ctx;
 	dma_cookie_t            cookie;
 #elif defined(CONFIG_SPI_NUC980_SPI0_NO_PDMA)
-	unsigned int    i;
+	unsigned int    i,j;
 
 	hw->tx = t->tx_buf;
 	hw->rx = t->rx_buf;
@@ -368,10 +370,27 @@ static int nuc980_spi0_txrx(struct spi_d
 
 #elif defined(CONFIG_SPI_NUC980_SPI0_NO_PDMA)
 	if (hw->rx) {
-		for(i = 0; i < t->len; i++) {
-			__raw_writel(hw_tx(hw, i), hw->regs + REG_TX);
-			while (((__raw_readl(hw->regs + REG_STATUS) & 0x100) == 0x100)); //RXEMPTY
-			hw_rx(hw, __raw_readl(hw->regs + REG_RX), i);
+		j = 0;
+
+		for(i = 0; i < t->len; ) {
+			if(((__raw_readl(hw->regs + REG_STATUS) & 0x20000) == 0x00000)) //TX NOT FULL
+			{
+				__raw_writel(hw_tx(hw, i), hw->regs + REG_TX);
+				i++;
+			}
+			if(((__raw_readl(hw->regs + REG_STATUS) & 0x100) == 0x000)) //RX NOT EMPTY
+			{
+				hw_rx(hw, __raw_readl(hw->regs + REG_RX), j);
+				j++;
+			}
+		}
+		while(j < t->len)
+		{
+			if(((__raw_readl(hw->regs + REG_STATUS) & 0x100) == 0x000)) //RX NOT EMPTY
+			{
+				hw_rx(hw, __raw_readl(hw->regs + REG_RX), j);
+				j++;
+			}
 		}
 	} else {
 		for(i = 0; i < t->len; i++) {
@@ -810,8 +829,14 @@ static int nuc980_spi0_probe(struct plat
 	p = devm_pinctrl_get_select(&pdev->dev, "spi0-ss1-PG15");
 #elif defined(CONFIG_SPI_NUC980_SPI0_PC) && !defined(CONFIG_SPI_NUC980_SPI0_SS1)
 	p = devm_pinctrl_get_select(&pdev->dev, "spi0-PC");
-#elif defined(CONFIG_SPI_NUC980_SPI0_PD) && defined(CONFIG_SPI_NUC980_SPI0_SS1_PC0)
+#if defined(CONFIG_BOARD_CHILI)
+	p = devm_pinctrl_get_select(&pdev->dev, "spi0-PC1");
+#endif
+#elif defined(CONFIG_SPI_NUC980_SPI0_PC) && defined(CONFIG_SPI_NUC980_SPI0_SS1_PC0)
 	p = devm_pinctrl_get_select(&pdev->dev, "spi0-ss1-PC0");
+#if defined(CONFIG_BOARD_CHILI)
+	p = devm_pinctrl_get_select(&pdev->dev, "spi0-ss1-PC0_1");
+#endif
 #endif
 #endif
 	if(IS_ERR(p)) {
diff -uprN linux-4.4.194/drivers/spi/spi-nuc980-spi1.c NUC980-linux-4.4.y-master/drivers/spi/spi-nuc980-spi1.c
--- linux-4.4.194/drivers/spi/spi-nuc980-spi1.c	2021-08-05 23:48:46.571220000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/spi-nuc980-spi1.c	2021-06-20 19:14:48.000000000 -0700
@@ -156,6 +156,8 @@ static inline void nuc980_slave_select(s
 			val |= SELECTSLAVE1;
 	}
 
+	while (__raw_readl(hw->regs + REG_STATUS) & 1); //wait busy
+
 	__raw_writel(val, hw->regs + REG_SSCTL);
 
 	spin_unlock_irqrestore(&hw->lock, flags);
@@ -230,7 +232,7 @@ static int nuc980_spi1_txrx(struct spi_d
 	struct nuc980_dma_config dma_crx,dma_ctx;
 	dma_cookie_t            cookie;
 #elif defined(CONFIG_SPI_NUC980_SPI1_NO_PDMA)
-	unsigned int    i;
+	unsigned int    i,j;
 
 	hw->tx = t->tx_buf;
 	hw->rx = t->rx_buf;
@@ -367,10 +369,27 @@ static int nuc980_spi1_txrx(struct spi_d
 
 #elif defined(CONFIG_SPI_NUC980_SPI1_NO_PDMA)
 	if (hw->rx) {
-		for(i = 0; i < t->len; i++) {
-			__raw_writel(hw_tx(hw, i), hw->regs + REG_TX);
-			while (((__raw_readl(hw->regs + REG_STATUS) & 0x100) == 0x100)); //RXEMPTY
-			hw_rx(hw, __raw_readl(hw->regs + REG_RX), i);
+		j = 0;
+
+		for(i = 0; i < t->len; ) {
+			if(((__raw_readl(hw->regs + REG_STATUS) & 0x20000) == 0x00000)) //TX NOT FULL
+			{
+				__raw_writel(hw_tx(hw, i), hw->regs + REG_TX);
+				i++;
+			}
+			if(((__raw_readl(hw->regs + REG_STATUS) & 0x100) == 0x000)) //RX NOT EMPTY
+			{
+				hw_rx(hw, __raw_readl(hw->regs + REG_RX), j);
+				j++;
+			}
+		}
+		while(j < t->len)
+		{
+			if(((__raw_readl(hw->regs + REG_STATUS) & 0x100) == 0x000)) //RX NOT EMPTY
+			{
+				hw_rx(hw, __raw_readl(hw->regs + REG_RX), j);
+				j++;
+			}
 		}
 	} else {
 		for(i = 0; i < t->len; i++) {
diff -uprN linux-4.4.194/drivers/spi/spi-omap2-mcspi.c NUC980-linux-4.4.y-master/drivers/spi/spi-omap2-mcspi.c
--- linux-4.4.194/drivers/spi/spi-omap2-mcspi.c	2019-09-20 22:12:54.000000000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/spi-omap2-mcspi.c	2021-06-20 19:14:48.000000000 -0700
@@ -301,7 +301,7 @@ static void omap2_mcspi_set_fifo(const s
 	struct omap2_mcspi_cs *cs = spi->controller_state;
 	struct omap2_mcspi *mcspi;
 	unsigned int wcnt;
-	int max_fifo_depth, fifo_depth, bytes_per_word;
+	int max_fifo_depth, bytes_per_word;
 	u32 chconf, xferlevel;
 
 	mcspi = spi_master_get_devdata(master);
@@ -317,10 +317,6 @@ static void omap2_mcspi_set_fifo(const s
 		else
 			max_fifo_depth = OMAP2_MCSPI_MAX_FIFODEPTH;
 
-		fifo_depth = gcd(t->len, max_fifo_depth);
-		if (fifo_depth < 2 || fifo_depth % bytes_per_word != 0)
-			goto disable_fifo;
-
 		wcnt = t->len / bytes_per_word;
 		if (wcnt > OMAP2_MCSPI_MAX_FIFOWCNT)
 			goto disable_fifo;
@@ -328,16 +324,17 @@ static void omap2_mcspi_set_fifo(const s
 		xferlevel = wcnt << 16;
 		if (t->rx_buf != NULL) {
 			chconf |= OMAP2_MCSPI_CHCONF_FFER;
-			xferlevel |= (fifo_depth - 1) << 8;
+			xferlevel |= (bytes_per_word - 1) << 8;
 		}
+
 		if (t->tx_buf != NULL) {
 			chconf |= OMAP2_MCSPI_CHCONF_FFET;
-			xferlevel |= fifo_depth - 1;
+			xferlevel |= bytes_per_word - 1;
 		}
 
 		mcspi_write_reg(master, OMAP2_MCSPI_XFERLEVEL, xferlevel);
 		mcspi_write_chconf0(spi, chconf);
-		mcspi->fifo_depth = fifo_depth;
+		mcspi->fifo_depth = max_fifo_depth;
 
 		return;
 	}
@@ -569,7 +566,6 @@ omap2_mcspi_txrx_dma(struct spi_device *
 	struct dma_slave_config	cfg;
 	enum dma_slave_buswidth width;
 	unsigned es;
-	u32			burst;
 	void __iomem		*chstat_reg;
 	void __iomem            *irqstat_reg;
 	int			wait_res;
@@ -591,22 +587,14 @@ omap2_mcspi_txrx_dma(struct spi_device *
 	}
 
 	count = xfer->len;
-	burst = 1;
-
-	if (mcspi->fifo_depth > 0) {
-		if (count > mcspi->fifo_depth)
-			burst = mcspi->fifo_depth / es;
-		else
-			burst = count / es;
-	}
 
 	memset(&cfg, 0, sizeof(cfg));
 	cfg.src_addr = cs->phys + OMAP2_MCSPI_RX0;
 	cfg.dst_addr = cs->phys + OMAP2_MCSPI_TX0;
 	cfg.src_addr_width = width;
 	cfg.dst_addr_width = width;
-	cfg.src_maxburst = burst;
-	cfg.dst_maxburst = burst;
+	cfg.src_maxburst = 1;
+	cfg.dst_maxburst = 1;
 
 	rx = xfer->rx_buf;
 	tx = xfer->tx_buf;
diff -uprN linux-4.4.194/drivers/spi/spi-rockchip.c NUC980-linux-4.4.y-master/drivers/spi/spi-rockchip.c
--- linux-4.4.194/drivers/spi/spi-rockchip.c	2019-09-20 22:12:54.000000000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/spi-rockchip.c	2021-06-20 19:14:48.000000000 -0700
@@ -444,6 +444,9 @@ static void rockchip_spi_prepare_dma(str
 	struct dma_slave_config rxconf, txconf;
 	struct dma_async_tx_descriptor *rxdesc, *txdesc;
 
+	memset(&rxconf, 0, sizeof(rxconf));
+	memset(&txconf, 0, sizeof(txconf));
+
 	spin_lock_irqsave(&rs->lock, flags);
 	rs->state &= ~RXBUSY;
 	rs->state &= ~TXBUSY;
diff -uprN linux-4.4.194/drivers/spi/spi-sh-msiof.c NUC980-linux-4.4.y-master/drivers/spi/spi-sh-msiof.c
--- linux-4.4.194/drivers/spi/spi-sh-msiof.c	2019-09-20 22:12:54.000000000 -0700
+++ NUC980-linux-4.4.y-master/drivers/spi/spi-sh-msiof.c	2021-06-20 19:14:48.000000000 -0700
@@ -1198,8 +1198,8 @@ static int sh_msiof_spi_probe(struct pla
 
 	i = platform_get_irq(pdev, 0);
 	if (i < 0) {
-		dev_err(&pdev->dev, "cannot get platform IRQ\n");
-		ret = -ENOENT;
+		dev_err(&pdev->dev, "cannot get IRQ\n");
+		ret = i;
 		goto err1;
 	}
 
